<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="https://raw.githubusercontent.com/UserStefDLT/WebResources/master/Images/icon_st.png">
    <title>Sector Check | Collision Simulation | Canvas Exp | NyteLabs</title>
    <link rel="stylesheet" href="../../../stylesheets/start.css">
    <link rel="stylesheet" href="../../../stylesheets/labst.css">
    <!-- <link rel="stylesheet" href="../../../stylesheets/radio-nav.css"> -->
    <!-- <link rel="stylesheet" href="../../../stylesheets/deck.css"> -->
    <!-- <link rel="stylesheet" href="../../../stylesheets/canvas.css"> -->
    <style>
        header {
            position: fixed;
            top: 0;
            z-index: 9;
            justify-content: end;
            box-shadow: 0 0 0 transparent;
        }
        header .title {padding-right: 12px;}
        main, .shelf {position: static;}
        [id*="canvas"] {
            position: absolute;
            inset: 0;
            background-color: #000;
            /* height: 100vh; width: 100vw; */
            height: 100%; width: 100%;
            /* height: 695px; width: 960px; */
        }
        #canvas_bg {opacity: .6;}
        #canvas_bg,
        #canvas,
        #canvas_hover {
            background-color: #0000;
        }
    </style>
    <link rel="stylesheet" href="../../../stylesheets/end.css">
</head>
<body>
    <header>
        <a href="../../../index.html" class="backLink"><div class="backBtn">Back?</div></a>
        <div class="title">Sector Check</div>
        <!-- <div class="subtitle">subtitle</div> -->
    </header>

<main>
    <!-- <div class="shelf">
        <div class="shelf-title">title</div>
    </div> -->
    <canvas id="canvas_bg"></canvas>
    <canvas id="canvas"></canvas>
</main>


    <footer>
        <div class="my-name">
            <a href="#">Back To Top</a>
            &copy; 2022 | by St√©fano De La Torre 
        </div>
    </footer>
    <div class="name-end">by St&eacute;fano.</div>
    <!-- <script src="main.js"></script> -->
    
    <script>
        const canvas_bg = document.getElementById('canvas_bg');
        const ctx_bg = canvas_bg.getContext('2d');
        canvas_bg.width = window.innerWidth;
        canvas_bg.height = window.innerHeight;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // window.addEventListener('resize', () =>{
        //     // canvas.width = window.innerWidth;
        //     // canvas.height = window.innerHeight;
        // });


        const particles = [];
        const s = {
            x: 0,
            y: 0,

            r: 3,
            c: 0,
            hue: 0,
            hue_steps: 6,
            hue_step: 360/6,
            lum_step: 20,

            'vh': window.innerHeight,
            'vw': window.innerWidth,

            pause: false,
            pause: false,
            z: 30
        }

        function hueHelix(){
            let chance = Math.floor(Math.random()*100) + 1;
            // let hue_add = Math.floor(Math.random()*2) + 1;
            let hue_add = 1;
            s.hue = s.hue + hue_add;
            if(chance > 0){
                for (let index = 0; index < s.hue_steps; index++) {
                    let hue = s.hue + (index * s.hue_step);
                    let dotOff = (Math.floor(Math.random()*s.z) + 20);
                    let radius = Math.floor(Math.random()*s.r) + 1;
                    let lum = dotOff - 10;

                    let cirX = Math.cos(Math.PI*(hue/180)) * dotOff;
                    let cirY = Math.sin(Math.PI*(hue/180)) * dotOff;
                    let x = cirX + s.x;
                    let y = cirY + s.y;
            
                    ctx.fillStyle = `hsl(${hue}, 100%, ${lum}%)`;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // const s = {
        //     'vh': window.innerHeight,
        //     'vw': window.innerWidth,
        // }
        const o = {'x': s.vw/2, 'y': s.vh/2};
        function DrawGrid1(ctx, space = 100){
            let rowCount = o.x / space;
            let colCount = o.y / space;
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#222';
            ctx.beginPath();
            for (let y = 1; y < rowCount; y++) {
                let ys = y*space;
                let oysup = o.y - ys;
                let oysdn = o.y + ys;
                ctx.moveTo(0, oysup);
                ctx.lineTo(s.vw, oysup);
                ctx.moveTo(0, oysdn);
                ctx.lineTo(s.vw, oysdn);
            }
            for (let x = 1; x < rowCount; x++) {
                let xs = x*space;
                let oxs_l = o.x - xs;
                let oxs_r = o.x + xs;
                ctx.moveTo(oxs_l, 0);
                ctx.lineTo(oxs_l, s.vh);
                ctx.moveTo(oxs_r, 0);
                ctx.lineTo(oxs_r, s.vh);
            }
            ctx.stroke();

            // ctx.strokeStyle = '#555';
            ctx.strokeStyle = '#999';
            ctx.beginPath();
            ctx.moveTo(o.x, 0);
            ctx.lineTo(o.x, s.vh);
            ctx.moveTo(0, o.y);
            ctx.lineTo(s.vw, o.y);
            ctx.stroke();

            for (let y = 1; y < rowCount; y++) {
                for (let x = 1; x < rowCount; x++) {
                    let ys = y*space;
                    let xs = x*space;
                    let text = `(${ys},${xs})`;
                    DrawTextA(ctx, text, {'x':xs,'y':ys}, hsla = {}, fontSize = 16, color = '#fff9', size = 1, fill = true)
                }
            }
        }
        function DrawGrid(ctx, space = 100){
            let rowCount = s.vh / space;
            let colCount = s.vw / space;
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#222';
            ctx.beginPath();
            for (let y = 0; y < rowCount; y++) {
                let ys = y*space;
                // let oysup = o.y - ys;
                // let oysdn = o.y + ys;
                // ctx.moveTo(0, oysup);
                // ctx.lineTo(s.vw, oysup);
                // ctx.moveTo(0, oysdn);
                // ctx.lineTo(s.vw, oysdn);

                ctx.moveTo(0, ys);
                ctx.lineTo(s.vw, ys);
            }
            for (let x = 0; x < colCount; x++) {
                let xs = x*space;
                // let oxs_l = o.x - xs;
                // let oxs_r = o.x + xs;
                // ctx.moveTo(oxs_l, 0);
                // ctx.lineTo(oxs_l, s.vh);
                // ctx.moveTo(oxs_r, 0);
                // ctx.lineTo(oxs_r, s.vh);

                ctx.moveTo(xs, 0);
                ctx.lineTo(xs, s.vh);
            }
            ctx.stroke();

            // // ctx.strokeStyle = '#555';
            // ctx.strokeStyle = '#999';
            // ctx.beginPath();
            // ctx.moveTo(o.x, 0);
            // ctx.lineTo(o.x, s.vh);
            // ctx.moveTo(0, o.y);
            // ctx.lineTo(s.vw, o.y);
            // ctx.stroke();

            // for (let y = 1; y < rowCount; y++) {
            //     for (let x = 1; x < rowCount; x++) {
            //         let ys = y*space;
            //         let xs = x*space;
            //         let text = `(${ys}, ${xs})`;
            //         DrawTextA(ctx, text, {'x':xs,'y':ys}, hsla = {}, fontSize = 16, color = '#fff9', size = 1, fill = true)
            //     }
            // }

            // for (let y = 0; y < rowCount; y++) {
            //     let ys = (y*space)+20;
            //     // let text = `(${ys})`;
            //     let text = `y:${y}`;
            //     DrawTextA(ctx, text, {'x':0,'y':ys}, hsla = {}, fontSize = 16, color = '#fff9', size = 1, fill = true)
            // }
            // for (let x = 0; x < rowCount; x++) {
            //     let xs = (x*space)+20;
            //     // let text = `(${xs})`;
            //     let text = `x:${x}`;
            //     DrawTextA(ctx, text, {'x':xs,'y':0}, hsla = {}, fontSize = 16, color = '#fff9', size = 1, fill = true)
            // }

            for (let y = 0; y < rowCount; y++) {
                for (let x = 0; x < colCount; x++) {
                    let ys = (y*space)+50;
                    let xs = (x*space)+50;
                    let text = `(${x},${y})`;
                    DrawTileText(ctx, text, {'x':xs,'y':ys}, hsla = {}, fontSize = 16, color = '#fff9', size = 1, fill = true)
                }
            }
        }

        function DrawTextA(ctx, text, yx = {'x':0,'y':0}, hsla = {}, fontSize = 16, color = '', size = 1, fill = true){
            // let xy = AngleToXY(angle);
            // let dx = xy.x;
            // let dy = xy.y;

            let colorStyle = '#0000';
            let colorStyle_stroke = '#ffff';
            let colorStyle_fill = '#fff3';

            if(Object.keys(hsla).length > 0){
                colorStyle = `hsla(${hsla.h}, ${hsla.s}%, ${hsla.l}%, ${hsla.a})`;
                colorStyle_stroke = `hsla(${hsla.h}, ${hsla.s}%, ${hsla.l}%, 1)`;
                // colorStyle_fill = `hsla(${hsla.h}, ${hsla.s}%, ${hsla.l}%, .2)`;
                // colorStyle_fill = `hsla(${hsla.h}, ${hsla.s}%, ${hsla.l-40}%, 1)`;
                // colorStyle_fill = `hsla(${hsla.h}, ${hsla.s}%, ${hsla.l-40}%, .2)`;
                // colorStyle_fill = `hsla(${hsla.h}, ${hsla.s}%, ${hsla.l-40}%, 1)`;
                colorStyle_fill = `hsla(${hsla.h}, ${hsla.s}%, 10%, 1)`;
            }
            if(color != '') {
                colorStyle = color;
                colorStyle_stroke = color;
                colorStyle_fill = color;
            }

            // let sz = size;
            // let sz_line = sz;
            // // let sz_point = sz * 2;

            // ctx.lineWidth = sz_line;
            
            
            ctx.font = `${fontSize}px serif`;
            ctx.textBaseline = "top";
            ctx.textAlign = "left";

            let padding = 2;
            let x = yx.x + padding;
            let y = yx.y + padding;

            // let txth = fontSize;
            // let text_width = ctx.measureText(text);
            // let txtw = text_width.width / 2;
            // // let txtw = text_width.width;
            
            // let x = o.x + (dx * (distance + txtw + 6));
            // // let x = o.x + (dx * (distance + text_width.width));
            // let y = o.y + (dy * (distance + txth));
            // // let y = o.y + (dy * (distance + fontSize));

            // let border = 1;
            // let padding = 2;
            // let txtw_m = (txtw + padding + border);
            // let txth_m = (txth/2 + padding + border);
            // let txtw_s = (txtw + padding);
            // let txth_s = (txth/2 + padding);
            
            // let label_x1_m = x - txtw_m;
            // let label_y1_m = y - txth_m;
            // // ctx.fillStyle = '#fff9';
            // // ctx.fillStyle = colorStyle_stroke;
            // // ctx.fillRect(label_x1_m, label_y1_m, txtw_m*2, txth_m*2);

            // // DrawRect(label_x1_m, label_y1_m, txtw_m*2, txth_m*2, colorStyle_stroke);

            // let label_x1 = x - txtw_s;
            // let label_y1 = y - txth_s;
            // // ctx.fillStyle = '#000f';
            // // ctx.fillRect(label_x1, label_y1, txtw_s*2, txth_s*2);
            // ctx.fillStyle = colorStyle_fill;
            // ctx.fillRect(label_x1, label_y1, txtw_s*2, txth_s*2);


            // DrawRect(ctx, label_x1_m, label_y1_m, txtw_m*2, txth_m*2, colorStyle_stroke);

            if(fill){
                ctx.fillStyle = colorStyle_stroke;
                ctx.fillText(text, x, y);
            } else {
                ctx.strokeStyle = colorStyle_stroke;
                ctx.strokeText(text, x, y);
            }

            // console.log(` ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ `);
        }
        function DrawTileText(ctx, text, yx = {'x':0,'y':0}, hsla = {}, fontSize = 16, color = '', size = 1, fill = true){
            let colorStyle = '#0000';
            let colorStyle_stroke = '#ffff';
            let colorStyle_fill = '#fff3';

            if(Object.keys(hsla).length > 0){
                colorStyle = `hsla(${hsla.h}, ${hsla.s}%, ${hsla.l}%, ${hsla.a})`;
                colorStyle_stroke = `hsla(${hsla.h}, ${hsla.s}%, ${hsla.l}%, 1)`;
                colorStyle_fill = `hsla(${hsla.h}, ${hsla.s}%, 10%, 1)`;
            }
            if(color != '') {
                colorStyle = color;
                colorStyle_stroke = color;
                colorStyle_fill = color;
            }
            
            ctx.font = `${fontSize}px serif`;
            ctx.textBaseline = "middle";
            ctx.textAlign = "center";

            let padding = 2;
            let x = yx.x + padding;
            let y = yx.y + padding;

            // let txth = fontSize;
            // let text_width = ctx.measureText(text);
            // let txtw = text_width.width / 2;
            // // let txtw = text_width.width;
            
            // let x = o.x + (dx * (distance + txtw + 6));
            // // let x = o.x + (dx * (distance + text_width.width));
            // let y = o.y + (dy * (distance + txth));
            // // let y = o.y + (dy * (distance + fontSize));

            // let border = 1;
            // let padding = 2;
            // let txtw_m = (txtw + padding + border);
            // let txth_m = (txth/2 + padding + border);
            // let txtw_s = (txtw + padding);
            // let txth_s = (txth/2 + padding);
            
            // let label_x1_m = x - txtw_m;
            // let label_y1_m = y - txth_m;
            // // ctx.fillStyle = '#fff9';
            // // ctx.fillStyle = colorStyle_stroke;
            // // ctx.fillRect(label_x1_m, label_y1_m, txtw_m*2, txth_m*2);

            // // DrawRect(label_x1_m, label_y1_m, txtw_m*2, txth_m*2, colorStyle_stroke);

            // let label_x1 = x - txtw_s;
            // let label_y1 = y - txth_s;
            // // ctx.fillStyle = '#000f';
            // // ctx.fillRect(label_x1, label_y1, txtw_s*2, txth_s*2);
            // ctx.fillStyle = colorStyle_fill;
            // ctx.fillRect(label_x1, label_y1, txtw_s*2, txth_s*2);


            // DrawRect(ctx, label_x1_m, label_y1_m, txtw_m*2, txth_m*2, colorStyle_stroke);

            if(fill){
                ctx.fillStyle = colorStyle_stroke;
                ctx.fillText(text, x, y);
            } else {
                ctx.strokeStyle = colorStyle_stroke;
                ctx.strokeText(text, x, y);
            }

            // console.log(` ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ `);
        }

        class Particle {
            constructor(id, speed, xyd = []){
                this.id = id;
                if(xyd.length > 0) {
                    this.x = xyd[0];
                    this.y = xyd[1];
                    this.d = xyd[2];
                } else {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.d = Math.floor(Math.random() * 360);
                }
                this.path = [[this.x,this.y,this.d]];
                this.speed = speed;
                console.log(`id:${this.id} ‚Üí ${this.d}deg.`);

                this.hue = this.id * 60;
                this.sat = 100;
                this.lum = 60;
                this.alp = 1;
                this.clr = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;

                this.size = 10;
                this.rad = 0;
                this.dx = 0;
                this.dy = 0;
                this.directionUpdate();

                this.forceQueue = [];
            }
            identify(){
                // console.log(`id:${this.id} ‚Üí ${this.d}deg.`);
                console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
                console.log(`id:${this.id} \n\t‚Üí a: ${this.d}deg. \n\t‚Üí sp: ${this.speed}. \n\t‚Üí x: ${this.x}, y: ${this.y}`);
                // console.log(`\t‚Üí x: ${this.x}, y: ${this.y}`);
                if(this.forceQueue.length > 0){
                    console.log(`\t‚Üí forceQueue: ${this.forceQueue.length}`);
                }
                console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
            }
            identify2(){
                console.log(`id:${this.id} \n\t‚Üí forceQueue: ${this.forceQueue.length}`);
                console.log(this.forceQueue);
            }
            identifyXY(){
                console.log(`\tid:${this.id} move ‚Üí (x:${this.x}, y:${this.y})`);
            }
            identifyForces(i){
                if(i==2) {console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);}
                if(i==1) {console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ identifyForces(‚Üì) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);}
                console.log(`id:${this.id} \n\t‚Üí angle: ${this.d}deg. \n\t‚Üí speed: ${this.speed}. \n\t‚Üí x: ${this.x}, y: ${this.y}`);
                if(this.forceQueue.length > 0){
                    console.log(`\t‚Üí forceQueue: ${this.forceQueue.length}`);
                    this.forceQueue.forEach(force => {
                        console.log(`\tforce ‚Üí speed: ${force.speed}, direction: ${force.d}`);
                    });
                }
                if(i==2) {console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ identifyForces(‚Üë) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);}
            }
            addForces(){
                // this.identifyForces(1);
                let this_x_force = this.speed * this.dx;
                let this_y_force = this.speed * this.dy;

                let adding_x_force = this_x_force;
                let adding_y_force = this_y_force;

                this.forceQueue.forEach(force => {
                    // console.log(`force.speed: ${force.speed}, force.d: ${force.d}`);
                    let xy = this.AngleToXY(force.d);
                    // console.log(`xy: ${xy.x}, ${xy.y}`);
                    let new_x_force = force.speed * xy.x;
                    let new_y_force = force.speed * xy.y;
                    // console.log(`new_x_force: ${new_x_force}, new_y_force:${new_y_force}`);
                    
                    adding_x_force += new_x_force;
                    adding_y_force += new_y_force;
                    // console.log(`adding_x_force: ${adding_x_force}, adding_y_force:${adding_y_force}`);
                });
                // let new_angle = this.XYtoAngle(adding_x_force,adding_y_force);
                // console.log(`new_angle: ${new_angle}`);
                this.d = this.XYtoAngle(adding_x_force,adding_y_force);
                // let speed_check = Math.sqrt(adding_x_force**2 + adding_y_force**2);
                // console.log(`speed_check: ${speed_check}`);
                this.speed = Math.sqrt(adding_x_force**2 + adding_y_force**2);
                // if(this.speed > 5) {this.speed = 5;}
                if(this.speed > 15) {this.speed = 15;}
                
                this.forceQueue = [];
                this.directionUpdate();
                this.move();
                // this.identifyForces(2);
            }
            AngleToXY(angle){
                angle = angle%360;
                let rad = angle * Math.PI / 180;
                let xy = {"x":0,"y":0};
                if(angle == 180) {xy.y = 0;} else {xy.y = Math.sin(rad);}
                if(angle == 90 || angle == 270) {xy.x = 0;} else {xy.x = Math.cos(rad);}
                return xy;
            }
            XYtoAngle(x,y){
                // let x = Math.floor(x);
                // let y = Math.floor(y);
                x = Math.floor(x*1000);
                y = Math.floor(y*1000);
                let angle = 0;
                if(x == 0) {
                    if(y > 0) {return 90;}
                    if(y < 0) {return 270;}
                }
                if(x < 0) { angle += 180; }
                if(y != 0) { angle += Math.atan(y/x) * 180 / Math.PI; }
                return angle;
            }
            updatePath(){
                this.path.push([this.x,this.y,this.d]);
                if(this.path.length > 4) {
                    this.path.shift();
                }
                // console.log(this.path);
            }
            directionUpdate(){
                // this.d = (this.d+360)%360;
                this.rad = this.d * Math.PI / 180;
                if(this.d == 180) {this.dy = 0;} else {this.dy = Math.sin(this.rad);}
                if(this.d == 90 || this.d == 270) {this.dx = 0;} else {this.dx = Math.cos(this.rad);}

                this.updatePath();

                // this.hue = this.direction - 90;
                // this.hue = this.hueStart + (this.direction%90) - 45;
                // this.size -= this.size/8;
                // if(this.size < 3) this.size = 3;

                // this.collisionCheck();
            }
            wallBounce(wall_angle){
                // console.log(`wallBounce(${wall_angle})`);
                // console.log(`this.d = ${this.d}`);
                let aper1 = (wall_angle + 90) % 360;
                let aper2 = (wall_angle + 270) % 360;
                let new_angle = 0;
                let dif = Math.abs(wall_angle - this.d)%180;
                if(dif != 0) {
                    let a1 = Math.max(aper1,aper2);
                    let a2 = Math.min(aper1,aper2);
                    new_angle = a1 + (a2 - this.d);
                }
                // return new_angle;
                // this.d = new_angle;
                this.d = (new_angle + 360) % 360;
                // console.log(`new_angle = ${new_angle}`);
                // console.log(`this.d = ${this.d}`);
            }
            move(){
                this.x += this.speed * this.dx;
                this.y += this.speed * this.dy;
                
                // this.identifyXY();
                // if(this.x > canvas.width || this.x < 0){
                //     if(this.d < 180) {
                //         this.d = 180 - this.d;
                //     } else {
                //         this.d = 270 + (270 - this.d);
                //     }
                //     this.directionUpdate();
                // }
                // if(this.y > canvas.height || this.y < 0){
                //     this.d = 360 - this.d;
                //     this.directionUpdate();
                // }

                if(this.x > canvas.width-1 || this.x < 1){
                    this.wallBounce(90);
                    this.directionUpdate();
                }
                if(this.y > canvas.height-1 || this.y < 1){
                    this.wallBounce(0);
                    this.directionUpdate();
                }
            }
            update(){
                // this.identify3();
                if(this.forceQueue.length > 0){
                    // console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
                    // this.identify2();
                    // addForce(this.forceQueue.speed, this.forceQueue.d);
                    this.addForces();
                    // console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
                }

                this.move();

                // this.clr = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
                // this.step = 314;
                // let xi = this.x % this.step;
                // let yi = this.y % this.step;

                // let xc = Math.cos(xi / 50);
                // let yc = Math.sin(yi / 50);
                // let xyc = xc + yc; /* -2 to 2 */

                // let lum_var = Math.floor(xyc * 10);
                // this.lum = 40 + lum_var;


                // this.collisionCheck();
                // console.log(`update of id:${this.id} done.`);
                // console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
            }
            draw(){
                this.drawPath();
                // ctx.fillStyle = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
                // this.clr = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
                ctx.fillStyle = this.clr;
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
            drawPath(){
                // this.clr = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
                // let alp2 = 1;
                if(this.path.length > 1){
                    ctx.beginPath();
                    // ctx.strokeStyle = this.clr;
                    // ctx.moveTo(this.x, this.y);
                    let ox = this.x;
                    let oy =  this.y;
                    for (let i = this.path.length - 1; i > 0; i--) {
                        let nx = this.path[i][0];
                        let ny = this.path[i][1];
                        
                        // ctx.beginPath();
                        // ctx.lineWidth = (i * 2) + 1;
                        ctx.lineWidth = i + 2;
                        // let alp2 = (i / this.path.length);
                        let alp2 = (i / this.path.length * .7) + .2;
                        ctx.strokeStyle = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${alp2})`;
                        ctx.moveTo(ox, oy);
                        ctx.lineTo(nx, ny);
                        ctx.stroke();
                        ox = nx;
                        oy = ny;
                    }
                }
            }
        }

        class Particle2 {
            constructor(id = -1, speed = 1, xyd = []){
                this.id = id;
                /* location = ('x', 'y'), and direction = ('d') */
                if(xyd.length > 0) {
                    this.x = xyd[0];
                    this.y = xyd[1];
                    this.d = xyd[2];
                } else {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.d = Math.floor(Math.random() * 360);
                }
                this.speed = speed;

                this.path = [[this.x,this.y,this.d]];
                console.log(`particle id:${this.id} at (${this.x.toFixed(2)},${this.y.toFixed(2)})`);

                this.hue = this.id * 60;
                this.sat = 100;
                this.lum = 60;
                this.alp = 1;
                this.clr = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;

                this.size = 10;
                this.rad = 0;
                this.dx = 0;
                this.dy = 0;
                this.directionUpdate();

                this.forceQueue = [];

                this.sid = '';
                this.stepCount = 0;
                this.sectorCheck();

                this.mass = 1;
                this.vel = 1;
                this.ke = this.mass * this.vel;

                this.tpsp = 0;
            }
            sectorCheck(){
                // console.log(`id(${this.id}) ‚Üí sectorCheck() ‚Üí this.sid: (${this.sid})`);
                // this.identifyXY();
                // console.log(`  ‚îî‚îÄ> id:${this.id} move ‚Üí (x:${this.x.toFixed(2)}, y:${this.y.toFixed(2)})`);

                /* change it so it takes more than 100, about 20 more on each side. */
                /* also, so it doesn't delete it unless it is outside of this extra area. */
                let xid = Math.floor(this.x/100);
                let yid = Math.floor(this.y/100);
                // let sid = `yx${yid}.${xid}`;
                // let sid = `xy${xid}.${yid}`;
                // let sid = `x${xid}y${yid}`;
                let sid = `${xid},${yid}`;
                // console.log(sid);
                if(sid != this.sid){
                    // console.log(`id(${this.id}) ‚Üí sectorCheck() ‚Üí this.sid: (${this.sid})`);
                    // console.log(`  ‚îî‚îÄ> id:${this.id} move ‚Üí (x:${this.x.toFixed(2)}, y:${this.y.toFixed(2)})`);
                    // console.log(`  ‚îî‚îÄ> new sid: (${sid})`);
                    console.log(`Particle (#${this.id}) ‚Üí new sid: (${sid})`);
                    if(this.sid != ''){
                        delete sector[this.sid][this.id];
                        if(Object.keys(sector[this.sid]).length == 0) {
                            delete sector[this.sid];
                        }
                    }
                    if(!Object.keys(sector).includes(sid)) {
                        sector[sid] = {}
                    }
                    // sector[sid][this.id] = true;
                    sector[sid][this.id] = this;
                    this.sid = sid;

                    // if(Object.keys(sector).length > 0) {
                    //     console.log(`sector keys: [${Object.keys(sector)}]`);
                    //     console.log(sector);
                    // }
                    // console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
                }
                //  else {
                //     console.log(`  ‚îî‚îÄX new sid: (${sid}) = old sid: (${this.sid})`);
                // }
                // console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
            }
            sectorUpdate(){
                if(this.sid != ''){
                    delete sector[this.sid][this.id];
                }
                let xid = Math.floor(this.x/100);
                let yid = Math.floor(this.y/100);
                let sid = `${yid},${xid}`;
                console.log(sid);
                if(!Object.keys(sector).includes(sid)) {
                    sector[sid] = {}
                }
                sector[sid][this.id] = true;
                this.sid = sid;
            }
            identify(){
                // console.log(`id:${this.id} ‚Üí ${this.d}deg.`);
                console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
                console.log(`id:${this.id} \n\t‚Üí a: ${this.d}deg. \n\t‚Üí sp: ${this.speed}. \n\t‚Üí x: ${this.x}, y: ${this.y}`);
                // console.log(`\t‚Üí x: ${this.x}, y: ${this.y}`);
                if(this.forceQueue.length > 0){
                    console.log(`\t‚Üí forceQueue: ${this.forceQueue.length}`);
                }
                console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
            }
            identifyXY(){
                console.log(`\tid:${this.id} move ‚Üí (x:${this.x}, y:${this.y})`);
            }
            identifyForces(i){
                if(i==2) {console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);}
                if(i==1) {console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ identifyForces(‚Üì) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);}
                console.log(`id:${this.id} \n\t‚Üí angle: ${this.d}deg. \n\t‚Üí speed: ${this.speed}. \n\t‚Üí x: ${this.x}, y: ${this.y}`);
                if(this.forceQueue.length > 0){
                    console.log(`\t‚Üí forceQueue: ${this.forceQueue.length}`);
                    this.forceQueue.forEach(force => {
                        console.log(`\tforce ‚Üí speed: ${force.speed}, direction: ${force.d}`);
                    });
                }
                if(i==2) {console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ identifyForces(‚Üë) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);}
            }
            addForces(){
                // this.identifyForces(1);
                let this_x_force = this.speed * this.dx;
                let this_y_force = this.speed * this.dy;

                let adding_x_force = this_x_force;
                let adding_y_force = this_y_force;

                this.forceQueue.forEach(force => {
                    // console.log(`force.speed: ${force.speed}, force.d: ${force.d}`);
                    let xy = this.AngleToXY(force.d);
                    // console.log(`xy: ${xy.x}, ${xy.y}`);
                    let new_x_force = force.speed * xy.x;
                    let new_y_force = force.speed * xy.y;
                    // console.log(`new_x_force: ${new_x_force}, new_y_force:${new_y_force}`);
                    
                    adding_x_force += new_x_force;
                    adding_y_force += new_y_force;
                    // console.log(`adding_x_force: ${adding_x_force}, adding_y_force:${adding_y_force}`);
                });
                // let new_angle = this.XYtoAngle(adding_x_force,adding_y_force);
                // console.log(`new_angle: ${new_angle}`);
                this.d = this.XYtoAngle(adding_x_force,adding_y_force);
                // let speed_check = Math.sqrt(adding_x_force**2 + adding_y_force**2);
                // console.log(`speed_check: ${speed_check}`);
                this.speed = Math.sqrt(adding_x_force**2 + adding_y_force**2);
                // if(this.speed > 5) {this.speed = 5;}
                if(this.speed > 15) {this.speed = 15;}
                
                this.forceQueue = [];
                this.directionUpdate();
                this.move();
                // this.identifyForces(2);
            }
            AngleToXY(angle){
                angle = angle%360;
                let rad = angle * Math.PI / 180;
                let xy = {"x":0,"y":0};
                if(angle == 180) {xy.y = 0;} else {xy.y = Math.sin(rad);}
                if(angle == 90 || angle == 270) {xy.x = 0;} else {xy.x = Math.cos(rad);}
                return xy;
            }
            XYtoAngle(x,y){
                x = Math.round(x*1000);
                y = Math.round(y*1000);
                let angle = 0;
                if(x == 0) {
                    if(y > 0) {return 90;}
                    if(y < 0) {return 270;}
                }
                if(x < 0) { angle += 180; }
                if(y != 0) { angle += Math.atan(y/x) * 180 / Math.PI; }
                return angle;
            }
            updatePath(){
                this.path.push([this.x,this.y,this.d]);
                if(this.path.length > 3) {
                    this.path.shift();
                }
                // console.log(this.path);
            }
            directionUpdate(){
                // this.d = (this.d+360)%360;
                this.rad = this.d * Math.PI / 180;
                if(this.d == 180) {this.dy = 0;} else {this.dy = Math.sin(this.rad);}
                if(this.d == 90 || this.d == 270) {this.dx = 0;} else {this.dx = Math.cos(this.rad);}

                this.updatePath();

                // this.hue = this.direction - 90;
                // this.hue = this.hueStart + (this.direction%90) - 45;
                // this.size -= this.size/8;
                // if(this.size < 3) this.size = 3;

                // this.collisionCheck();
            }
            wallBounce(wall_angle){
                // console.log(`wallBounce(${wall_angle})`);
                // console.log(`this.d = ${this.d}`);
                let aper1 = (wall_angle + 90) % 360;
                let aper2 = (wall_angle + 270) % 360;
                let new_angle = 0;
                let dif = Math.abs(wall_angle - this.d)%180;
                if(dif != 0) {
                    let a1 = Math.max(aper1,aper2);
                    let a2 = Math.min(aper1,aper2);
                    new_angle = a1 + (a2 - this.d);
                }
                // return new_angle;
                // this.d = new_angle;
                this.d = (new_angle + 360) % 360;
                // console.log(`new_angle = ${new_angle}`);
                // console.log(`this.d = ${this.d}`);
            }
            move(){
                this.x += this.speed * this.dx;
                this.y += this.speed * this.dy;
                // this.identifyXY();

                // if(this.x > canvas.width-1 || this.x < 1){
                //     this.wallBounce(90);
                //     this.directionUpdate();
                // }
                // if(this.y > canvas.height-1 || this.y < 1){
                //     this.wallBounce(0);
                //     this.directionUpdate();
                // }

                if(this.x > canvas.width-this.size || this.x < this.size){
                    this.wallBounce(90);
                    this.directionUpdate();
                }
                if(this.y > canvas.height-this.size || this.y < this.size){
                    this.wallBounce(0);
                    this.directionUpdate();
                }


                this.stepCount += 1;
                if(this.stepCount > 10){
                    this.sectorCheck();
                    this.stepCount = 0;
                }
            }
            update(){
                // this.identify3();
                if(this.forceQueue.length > 0){
                    console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
                    // console.log(this.forceQueue);
                    // PrintObj(this.forceQueue, 'forceQueue');
                    // this.identify2();
                    // addForce(this.forceQueue.speed, this.forceQueue.d);
                    this.addForces();
                    // console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
                    
                    // let pid = `p${this.id}`;
                    // // if(this.tpsp != CheckSpeed()){
                    // if(initialSpeed.toFixed(4) != CheckSpeed().toFixed(4)){
                    //     console.log(`initialSpeed != CheckSpeed(): ${initialSpeed != CheckSpeed()}`);
                    //     console.log(`initialSpeed: ${initialSpeed}`);
                    //     console.log(`CheckSpeed(): ${CheckSpeed()}`);
                    //     // console.error('üí•Catastrophic Collision Error‚ùó');
                    //     // console.warn('üí•Catastrophic Collision Error‚ùó');
                    //     console.warn('üí¢Collision Error‚ùó');
                    //     // console.log(`id: ${this.id}`);
                    //     // console.log(memoryStates[`p${this.id}`]);
                    //     // PrintObj(memoryStates[`p${this.id}`]);
                    //     PrintObj(memoryStates[pid], pid);
                    //     speedCount();
                    //     pause();
                    // } else {
                    //     MemoryUpdate();
                    //     console.log('%cMemoryUpdate()', 'color: #AA00AA;');
                    //     // console.log(`id: ${this.id}`);
                    //     // console.log(memoryStates[`p${this.id}`]);
                    //     PrintObj(memoryStates[pid], pid);
                    //     speedCount();
                    // }
                }

                this.move();

                // this.clr = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
                // this.step = 314;
                // let xi = this.x % this.step;
                // let yi = this.y % this.step;

                // let xc = Math.cos(xi / 50);
                // let yc = Math.sin(yi / 50);
                // let xyc = xc + yc; /* -2 to 2 */

                // let lum_var = Math.floor(xyc * 10);
                // this.lum = 40 + lum_var;


                // this.collisionCheck();
                // console.log(`update of id:${this.id} done.`);
                // console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
            }
            draw(){
                this.drawPath();
                // ctx.fillStyle = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
                // this.clr = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
                ctx.fillStyle = this.clr;
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
            drawPath(){
                // this.clr = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
                // let alp2 = 1;
                if(this.path.length > 1){
                    ctx.beginPath();
                    // ctx.strokeStyle = this.clr;
                    // ctx.moveTo(this.x, this.y);
                    let ox = this.x;
                    let oy =  this.y;
                    for (let i = this.path.length - 1; i > 0; i--) {
                        let nx = this.path[i][0];
                        let ny = this.path[i][1];
                        
                        // ctx.beginPath();
                        // ctx.lineWidth = (i * 2) + 1;
                        ctx.lineWidth = i + 2;
                        // let alp2 = (i / this.path.length);
                        let alp2 = (i / this.path.length * .7) + .2;
                        ctx.strokeStyle = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${alp2})`;
                        ctx.moveTo(ox, oy);
                        ctx.lineTo(nx, ny);
                        ctx.stroke();
                        ox = nx;
                        oy = ny;
                    }
                }
            }
        }
        
        class Particle3 {
            constructor(id = -1, speed = 1, xyd = []){
                this.id = id;
                /* location = ('x', 'y'), and direction = ('d') */
                if(xyd.length > 0) {
                    this.x = xyd[0];
                    this.y = xyd[1];
                    this.d = xyd[2];
                } else {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.d = Math.floor(Math.random() * 360);
                }
                this.speed = speed;

                this.path = [[this.x,this.y,this.d]];
                console.log(`particle id:${this.id} at (${this.x.toFixed(2)},${this.y.toFixed(2)})`);

                this.hue = this.id * 60;
                this.sat = 100;
                this.lum = 60;
                this.alp = 1;
                this.clr = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;

                this.size = 10;
                this.rad = 0;
                this.dx = 0;
                this.dy = 0;
                this.vx = 0;
                this.vy = 0;
                this.directionUpdate();

                this.forceQueue = [];
                this.momentumQueue = [];

                this.sid = '';
                this.stepCount = 0;
                this.sectorCheck();

                this.mass = 1;
                this.vel = 1;
                this.ke = this.mass * this.vel;

                this.tpsp = 0;
            }
            sectorCheck(){
                // console.log(`id(${this.id}) ‚Üí sectorCheck() ‚Üí this.sid: (${this.sid})`);
                // this.identifyXY();
                // console.log(`  ‚îî‚îÄ> id:${this.id} move ‚Üí (x:${this.x.toFixed(2)}, y:${this.y.toFixed(2)})`);

                /* change it so it takes more than 100, about 20 more on each side. */
                /* also, so it doesn't delete it unless it is outside of this extra area. */
                let xid = Math.floor(this.x/100);
                let yid = Math.floor(this.y/100);
                // let sid = `yx${yid}.${xid}`;
                // let sid = `xy${xid}.${yid}`;
                // let sid = `x${xid}y${yid}`;
                let sid = `${xid},${yid}`;
                // console.log(sid);
                if(sid != this.sid){
                    // console.log(`id(${this.id}) ‚Üí sectorCheck() ‚Üí this.sid: (${this.sid})`);
                    // console.log(`  ‚îî‚îÄ> id:${this.id} move ‚Üí (x:${this.x.toFixed(2)}, y:${this.y.toFixed(2)})`);
                    // console.log(`  ‚îî‚îÄ> new sid: (${sid})`);
                    console.log(`Particle (#${this.id}) ‚Üí new sid: (${sid})`);
                    if(this.sid != ''){
                        delete sector[this.sid][this.id];
                        if(Object.keys(sector[this.sid]).length == 0) {
                            delete sector[this.sid];
                        }
                    }
                    if(!Object.keys(sector).includes(sid)) {
                        sector[sid] = {}
                    }
                    // sector[sid][this.id] = true;
                    sector[sid][this.id] = this;
                    this.sid = sid;

                    // if(Object.keys(sector).length > 0) {
                    //     console.log(`sector keys: [${Object.keys(sector)}]`);
                    //     console.log(sector);
                    // }
                    // console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
                }
                //  else {
                //     console.log(`  ‚îî‚îÄX new sid: (${sid}) = old sid: (${this.sid})`);
                // }
                // console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
            }
            sectorUpdate(){
                if(this.sid != ''){
                    delete sector[this.sid][this.id];
                }
                let xid = Math.floor(this.x/100);
                let yid = Math.floor(this.y/100);
                let sid = `${yid},${xid}`;
                console.log(sid);
                if(!Object.keys(sector).includes(sid)) {
                    sector[sid] = {}
                }
                sector[sid][this.id] = true;
                this.sid = sid;
            }
            identify(){
                // console.log(`id:${this.id} ‚Üí ${this.d}deg.`);
                console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
                console.log(`id:${this.id} \n\t‚Üí a: ${this.d}deg. \n\t‚Üí sp: ${this.speed}. \n\t‚Üí x: ${this.x}, y: ${this.y}`);
                // console.log(`\t‚Üí x: ${this.x}, y: ${this.y}`);
                if(this.forceQueue.length > 0){
                    console.log(`\t‚Üí forceQueue: ${this.forceQueue.length}`);
                }
                console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
            }
            identifyXY(){
                console.log(`\tid:${this.id} move ‚Üí (x:${this.x}, y:${this.y})`);
            }
            identifyForces(i){
                if(i==2) {console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);}
                if(i==1) {console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ identifyForces(‚Üì) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);}
                console.log(`id:${this.id} \n\t‚Üí angle: ${this.d}deg. \n\t‚Üí speed: ${this.speed}. \n\t‚Üí x: ${this.x}, y: ${this.y}`);
                if(this.forceQueue.length > 0){
                    console.log(`\t‚Üí forceQueue: ${this.forceQueue.length}`);
                    this.forceQueue.forEach(force => {
                        console.log(`\tforce ‚Üí speed: ${force.speed}, direction: ${force.d}`);
                    });
                }
                if(i==2) {console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ identifyForces(‚Üë) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);}
            }
            addMomentum(){
                PrintObj(this.momentumQueue, `momentumQueue:${this.id}`);
                // let this_x_force = this.speed * this.dx;
                // let this_y_force = this.speed * this.dy;

                // this.vx = this.speed * this.dx;
                // this.vy = this.speed * this.dy;

                let adding_x_force = this.vx;
                let adding_y_force = this.vy;

                this.momentumQueue.forEach(dm => {
                    adding_x_force += dm.dxq;
                    adding_y_force += dm.dyq;
                });
                this.d = this.XYtoAngle(adding_x_force,adding_y_force);
                this.speed = Math.sqrt(adding_x_force**2 + adding_y_force**2);
                if(this.speed > 15) {this.speed = 15;}

                this.momentumQueue = [];
                this.directionUpdate();
                this.move();
            }
            addForces(){
                // this.identifyForces(1);
                let this_x_force = this.speed * this.dx;
                let this_y_force = this.speed * this.dy;

                let adding_x_force = this_x_force;
                let adding_y_force = this_y_force;

                this.forceQueue.forEach(force => {
                    // console.log(`force.speed: ${force.speed}, force.d: ${force.d}`);
                    let xy = this.AngleToXY(force.d);
                    // console.log(`xy: ${xy.x}, ${xy.y}`);
                    let new_x_force = force.speed * xy.x;
                    let new_y_force = force.speed * xy.y;
                    // console.log(`new_x_force: ${new_x_force}, new_y_force:${new_y_force}`);
                    
                    adding_x_force += new_x_force;
                    adding_y_force += new_y_force;
                    // console.log(`adding_x_force: ${adding_x_force}, adding_y_force:${adding_y_force}`);
                });
                // let new_angle = this.XYtoAngle(adding_x_force,adding_y_force);
                // console.log(`new_angle: ${new_angle}`);
                this.d = this.XYtoAngle(adding_x_force,adding_y_force);
                // let speed_check = Math.sqrt(adding_x_force**2 + adding_y_force**2);
                // console.log(`speed_check: ${speed_check}`);
                this.speed = Math.sqrt(adding_x_force**2 + adding_y_force**2);
                // if(this.speed > 5) {this.speed = 5;}
                if(this.speed > 15) {this.speed = 15;}
                
                this.forceQueue = [];
                this.directionUpdate();
                this.move();
                // this.identifyForces(2);
            }
            AngleToXY(angle){
                angle = angle%360;
                let rad = angle * Math.PI / 180;
                let xy = {"x":0,"y":0};
                if(angle == 180) {xy.y = 0;} else {xy.y = Math.sin(rad);}
                if(angle == 90 || angle == 270) {xy.x = 0;} else {xy.x = Math.cos(rad);}
                return xy;
            }
            XYtoAngle(x,y){
                x = Math.round(x*1000);
                y = Math.round(y*1000);
                let angle = 0;
                if(x == 0) {
                    if(y > 0) {return 90;}
                    if(y < 0) {return 270;}
                }
                if(x < 0) { angle += 180; }
                if(y != 0) { angle += Math.atan(y/x) * 180 / Math.PI; }
                return angle;
            }
            updatePath(){
                this.path.push([this.x,this.y,this.d]);
                if(this.path.length > 3) {
                    this.path.shift();
                }
                // console.log(this.path);
            }
            directionUpdate(){
                // this.d = (this.d+360)%360;
                this.rad = this.d * Math.PI / 180;
                if(this.d == 180) {this.dy = 0;} else {this.dy = Math.sin(this.rad);}
                if(this.d == 90 || this.d == 270) {this.dx = 0;} else {this.dx = Math.cos(this.rad);}

                this.vx = this.speed * this.dx;
                this.vy = this.speed * this.dy;
                this.updatePath();

                // this.hue = this.direction - 90;
                // this.hue = this.hueStart + (this.direction%90) - 45;
                // this.size -= this.size/8;
                // if(this.size < 3) this.size = 3;

                // this.collisionCheck();
            }
            wallBounce(wall_angle){
                // console.log(`wallBounce(${wall_angle})`);
                // console.log(`this.d = ${this.d}`);
                let aper1 = (wall_angle + 90) % 360;
                let aper2 = (wall_angle + 270) % 360;
                let new_angle = 0;
                let dif = Math.abs(wall_angle - this.d)%180;
                if(dif != 0) {
                    let a1 = Math.max(aper1,aper2);
                    let a2 = Math.min(aper1,aper2);
                    new_angle = a1 + (a2 - this.d);
                }
                // return new_angle;
                // this.d = new_angle;
                this.d = (new_angle + 360) % 360;
                // console.log(`new_angle = ${new_angle}`);
                // console.log(`this.d = ${this.d}`);
            }
            move(){
                this.x += this.speed * this.dx;
                this.y += this.speed * this.dy;
                // this.identifyXY();

                // if(this.x > canvas.width-1 || this.x < 1){
                //     this.wallBounce(90);
                //     this.directionUpdate();
                // }
                // if(this.y > canvas.height-1 || this.y < 1){
                //     this.wallBounce(0);
                //     this.directionUpdate();
                // }

                if(this.x > canvas.width-this.size || this.x < this.size){
                    this.wallBounce(90);
                    this.directionUpdate();
                }
                if(this.y > canvas.height-this.size || this.y < this.size){
                    this.wallBounce(0);
                    this.directionUpdate();
                }


                this.stepCount += 1;
                if(this.stepCount > 10){
                    this.sectorCheck();
                    this.stepCount = 0;
                }
            }
            update(){
                // this.identify3();
                if(this.forceQueue.length > 0){
                    // console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
                    // console.log(this.forceQueue);
                    // PrintObj(this.forceQueue, 'forceQueue');
                    // this.identify2();
                    this.addForces();
                    // console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
                }
                if(this.momentumQueue.length > 0){
                    // console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
                    console.log(`üí®`);
                    this.addMomentum();
                    // console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
                }

                this.move();

                // this.clr = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
                // this.step = 314;
                // let xi = this.x % this.step;
                // let yi = this.y % this.step;

                // let xc = Math.cos(xi / 50);
                // let yc = Math.sin(yi / 50);
                // let xyc = xc + yc; /* -2 to 2 */

                // let lum_var = Math.floor(xyc * 10);
                // this.lum = 40 + lum_var;


                // this.collisionCheck();
                // console.log(`update of id:${this.id} done.`);
                // console.log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
            }
            draw(){
                this.drawPath();
                // ctx.fillStyle = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
                // this.clr = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
                ctx.fillStyle = this.clr;
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
            drawPath(){
                // this.clr = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
                // let alp2 = 1;
                if(this.path.length > 1){
                    ctx.beginPath();
                    // ctx.strokeStyle = this.clr;
                    // ctx.moveTo(this.x, this.y);
                    let ox = this.x;
                    let oy =  this.y;
                    for (let i = this.path.length - 1; i > 0; i--) {
                        let nx = this.path[i][0];
                        let ny = this.path[i][1];
                        
                        // ctx.beginPath();
                        // ctx.lineWidth = (i * 2) + 1;
                        ctx.lineWidth = i + 2;
                        // let alp2 = (i / this.path.length);
                        let alp2 = (i / this.path.length * .7) + .2;
                        ctx.strokeStyle = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${alp2})`;
                        ctx.moveTo(ox, oy);
                        ctx.lineTo(nx, ny);
                        ctx.stroke();
                        ox = nx;
                        oy = ny;
                    }
                }
            }
        }

        
        /*
        sectorUpdate(){
            delete sector[this.sid][this.id];
            let xid = Math.floor(this.x/100);
            let yid = Math.floor(this.y/100);
            let sid = `${yid},${xid}`;
            if(!Object.keys(sector).includes(sid)) {
                sector[sid] = {}
            }
            sector[sid][this.id] = true;
            this.sid = sid;
        }
        */

        function AngleToXY(angle){
                let rad = angle * Math.PI / 180;
                let xy = {"x":0,"y":0};
                if(angle == 180) {xy.y = 0;} else {xy.y = Math.sin(rad);}
                if(angle == 90 || angle == 270) {xy.x = 0;} else {xy.x = Math.cos(rad);}
                return xy;
        }
        function XYtoAngle(x,y){
            x = Math.round(x*1000);
            y = Math.round(y*1000);
            let angle = 0;
            if(x == 0) {
                if(y > 0) {return 90;}
                if(y < 0) {return 270;}
            }
            if(x < 0) { angle += 180; }
            if(y != 0) { angle += Math.atan(y/x) * 180 / Math.PI; }
            return angle;
        }
        function collisionUpdate(a,b){
            /* 'a' is colliding into 'b' which can be at rest. */
            // console.log(`...collisionUpdate(${a.id},${b.id});`);
            // a.identify();
            // let xyStyle = 'color: #00AAAA; font-weight: bold; padding: .25rem .5rem;';
            let txtStyle = 'color: #AAAAAA; font-weight: bold;';
            let xyStyle = 'color: #00AAAA; font-weight: bold;';
            console.log(`%ca:%c(${a.x.toFixed(2)},${a.y.toFixed(2)})%c; b:%c(${b.x.toFixed(2)},${b.y.toFixed(2)})`, txtStyle, xyStyle, txtStyle, xyStyle);

            // item 'a' will be the collider into item 'b'.
            if(a.speed > 0){
                // console.log(`...collisionUpdate(${a.id},${b.id});`);
                // a.identify();
                let x2 = b.x - a.x;
                let y2 = b.y - a.y;
                // console.log(`x2: ${x2}, y2: ${y2}`);

                let collision_angle = XYtoAngle(x2,y2);
                console.log(`collision_angle: ${collision_angle}`);

                let apperture = Math.abs(collision_angle - a.d);
                // console.log(`apperture: ${apperture}`);

                //let force_ratio_y = Math.sin(apperture * Math.PI / 180);
                //let force_ratio = force_ratio_x + force_ratio_y;
                //let force_to_send = (force_ratio_x/force_ratio) * a.speed;
                // let force_to_keep = a.speed - force_to_send;

                if(apperture > 180) {apperture = 360 - apperture;}

                // // /* ‚ô¶ Change from angle and speed for dx and dy. ‚ô¶ */
                // // // let dxc = a.dx - b.dx;

                let xc = b.x - a.x;
                let yc = b.y - a.y;
                let x_force = 0;
                let y_force = 0;
                // console.log(`a.vx: ${a.vx}, xc: ${xc}, a.vx/xc: ${a.vx/xc}`);
                // console.log(`a.vy: ${a.vy}, yc: ${yc}, a.yx/yc: ${a.vy/yc}`);
                // console.log(`Math.cos(apperture * Math.PI / 180): ${Math.cos(apperture * Math.PI / 180)}`);
                if(a.vx == 0 || a.vx/xc > 0){
                    // let x_force = (a.vx - b.vx) * (1-Math.cos(apperture * Math.PI / 180));
                    // console.log(`a.vx: ${a.vx}, b.vx: ${b.vx}`);
                    // x_force = (a.vx - b.vx) * (Math.cos(apperture * Math.PI / 180));
                    x_force = (a.vx - b.vx) * (1-Math.sin(apperture * Math.PI / 180));
                }
                if(a.vy == 0 || a.vy/yc > 0){
                    // let y_force = (a.vy - b.vy) * (1-Math.sin(apperture * Math.PI / 180));
                    // console.log(`a.vy: ${a.vy}, b.vy: ${b.vy}`);
                    // y_force = (a.vy - b.vy) * (Math.sin(apperture * Math.PI / 180));
                    y_force = (a.vy - b.vy) * (1-Math.cos(apperture * Math.PI / 180));
                }
                console.log(`a ‚Üí dxq: ${x_force*-1}, dyq: ${y_force*-1}`);
                console.log(`b ‚Üí dxq: ${x_force}, dyq: ${y_force}`);
                a.momentumQueue.push({'dxq':x_force*-1, 'dyq':y_force*-1});
                b.momentumQueue.push({'dxq':x_force, 'dyq':y_force});


                if(apperture < 90) {
                    console.log(`apperture: ${apperture}`);
                    let force_ratio_x = Math.cos(apperture * Math.PI / 180);
                    let force_to_send = (force_ratio_x) * a.speed;
                    let collision_update = (collision_angle + 180)%360;
                    a.forceQueue.push({'speed':force_to_send, 'd':collision_update});
                    b.forceQueue.push({'speed':force_to_send, 'd':collision_angle});
                }


                // speedCount();
                // console.log(`...end of collisionUpdate(${a.id},${b.id})`);
            }
            // console.log(`...end of collisionUpdate(${a.id},${b.id})`);
        }
        function collisionCheck(a,b){
            // console.log(`..collisionCheck(${a.id},${b.id});`);
            // let x2 = a.x - b.x;
            // let y2 = a.y - b.y;
            let x2 = b.x - a.x;
            let y2 = b.y - a.y;
            let h = x2**2 + y2**2;
            let dist2 = (a.size+b.size)**2;
            if(h < dist2){
                collisionUpdate(a,b);
                collisionUpdate(b,a);
            }
            // console.log(`..end of collisionCheck(${a.id},${b.id})`);
        }
        
        function pairing(arr){
            // console.log(`.pairing(${arr.length})`);
            for(let i = 0; i < arr.length - 1; i++){
                let e1 = arr[i];
                for(let j = i+1; j < arr.length; j++){
                    let e2 = arr[j];
                    collisionCheck(e1,e2);
                }
            }
            // console.log(`.end of pairing(${arr.length})`);
        }
        const sector = {};
        const ss = {
            "sector": {"size": 100, "pps": 10}
        };
        function sectorPairing(sectList){
            // console.log(`.sectorPairing(${Object.keys(sectList).length})`);
            for(let i = 0; i < Object.keys(sectList).length - 1; i++){
                // let id = Object.keys(sectList)[i];
                // let e1 = sectList[id];
                let e1 = sectList[Object.keys(sectList)[i]];
                for(let j = i+1; j < Object.keys(sectList).length; j++){
                    // let e2 = arr[j];
                    // let e2 = sectList[id];
                    let e2 = sectList[Object.keys(sectList)[j]];
                    collisionCheck(e1,e2);
                }
            }
            // console.log(`.end of sectorPairing(${Object.keys(sectList).length})`);
        }
        function sectorCheck(){
            let sectorList = Object.keys(sector);
            // console.log(`sectorList: [${sectorList}] | length: (${sectorList.length})`);
            for(let i = 0; i < sectorList.length; i++){
                // let sectorId = sectorList[i];
                // console.log(`sectorId: ${sectorId}`);
                // let keys = Object.keys(sector[sectorId]);
                // let keys = Object.keys(sector[sectorList[i]]);
                // let keys = Object.keys(sector[Object.keys(sector)[i]]);
                let keys = Object.keys(sector[sectorList[i]]);
                // console.log(` ‚îî‚îÄ> keys: [${keys}] | length: (${keys.length})`);
                // console.log(` sector ‚Üí keys: [${keys}] | length: (${keys.length})`);
                
                if(keys.length > 1){
                    console.log(` sector ‚Üí keys: [${keys}] | length: (${keys.length})`);
                    // console.log(sector[sectorList[i]]);
                    // console.log(sector);
                    sectorPairing(sector[sectorList[i]]);
                }
                
            }

        }

        function ContinualCollisionUpdate3(a,b,h,ca){
            // attempt to determine the moment of collision to 
            // then calculate the collision, 
            // and then move the rest of momentum with the new directions.
            if(a.speed > 0){
                let x2 = b.x - a.x;
                let y2 = b.y - a.y;
                // console.log(`x2: ${x2}, y2: ${y2}`);
                let absize = a.size + b.size;
                console.log(`absize: %c${absize}`, "color: #06f",);

                console.log(`collision_angle: %c${ca.toFixed(4)}deg`, "color: #06f",);
                let apperture = Math.abs(ca - a.d);
                if(apperture > 180) {apperture = 360 - apperture;}
                console.log(`apperture: %c${apperture.toFixed(4)}deg`, "color: #06f",);
                
                console.log(`let xh = h*cos(ca);`);
                let xh = h*Math.cos(ca);
                let yh = h*Math.sin(ca);
                console.log(`%cxh: %c${xh.toFixed(4)}%c, yh: %c${yh.toFixed(4)}`, "color: white", "color: #06f", "color: white", "color: #06f");
                
                let xd = absize * Math.cos(ca);
                let yd = absize * Math.sin(ca);
                console.log(`%cxd: %c${xd.toFixed(4)}%c, yd: %c${yd.toFixed(4)}`, "color: white", "color: #06f", "color: white", "color: #06f");

                let xdh = xd - xh;
                let ydh = yd - yh;
                console.log(`%cxdh: %c${xdh.toFixed(4)}%c, ydh: %c${ydh.toFixed(4)}`, "color: white", "color: #06f", "color: white", "color: #06f");

                console.log(`%ca.dx: %c${a.dx.toFixed(4)}%c, a.dy: %c${a.dy.toFixed(4)}`, "color: white", "color: #06f", "color: white", "color: #06f");
                console.log(`%cb.dx: %c${b.dx.toFixed(4)}%c, b.dy: %c${b.dy.toFixed(4)}`, "color: white", "color: #06f", "color: white", "color: #06f");

                console.log(`%ca.vx: %c${a.vx.toFixed(4)}%c, a.vy: %c${a.vy.toFixed(4)}`, "color: white", "color: #06f", "color: white", "color: #06f");
                console.log(`%cb.vx: %c${b.vx.toFixed(4)}%c, b.vy: %c${b.vy.toFixed(4)}`, "color: white", "color: #06f", "color: white", "color: #06f");

                let tcx = (xd - xh) / a.vx;
                let tcy = (yd - yh) / a.vy;
                console.log(`%ctcx: %c${tcx.toFixed(4)}%c, tcy: %c${tcy.toFixed(4)}`, "color: white", "color: #06f", "color: white", "color: #06f");
                let tcx_1 = 1-tcx;
                let tcy_1 = 1-tcy;
                console.log(`%ctcx_1: %c${tcx_1.toFixed(4)}%c, tcy_1: %c${tcy_1.toFixed(4)}`, "color: white", "color: #06f", "color: white", "color: #06f");

                pause();
            }
        }
        function CollisionLog(){
            // if(this.tpsp != CheckSpeed()){
            if(initialSpeed.toFixed(4) != CheckSpeed().toFixed(4)){
                console.warn('üí¢Collision Error‚ùó');
                speedCount();

                particles.forEach(p=>{
                    let pid = `p${p.id}`;
                    PrintObj(memoryStates[pid], pid);
                });
                // console.log(`initialSpeed != CheckSpeed(): ${initialSpeed != CheckSpeed()}`);
                // console.log(`initialSpeed: ${initialSpeed}`);
                // console.log(`CheckSpeed(): ${CheckSpeed()}`);

                // console.error('üí•Catastrophic Collision Error‚ùó');
                // console.warn('üí•Catastrophic Collision Error‚ùó');
                // console.log(`id: ${this.id}`);
                // console.log(memoryStates[`p${this.id}`]);
                // PrintObj(memoryStates[`p${this.id}`]);
                // PrintObj(memoryStates[pid], pid);
                // speedCount();
                s.pause = true;
                // if(!s.q){
                //     pause();
                // }
            } else {
                MemoryUpdate();
                // console.log('%cMemoryUpdate()', 'color: #AA00AA;');
                console.log('\x1B[35mMemoryUpdate()\x1B[m');
                // console.log(`id: ${this.id}`);
                // console.log(memoryStates[`p${this.id}`]);
                // PrintObj(memoryStates[pid], pid);
                speedCount();
                // setTimeout(() => {
                //     // console.log("Delayed for 1 second.");
                //     speedCount();
                // }, "1000")
            }
        }
        function CollisionCheck3(a,b,t=''){
            let x2 = b.x - a.x;
            let y2 = b.y - a.y;
            // let h = x2**2 + y2**2;
            // let dist2 = (a.size+b.size)**2;
            let h = Math.sqrt(x2**2 + y2**2);
            let dist2 = (a.size+b.size);
            // console.log(`a.x = ${a.x} | b.x = ${b.x} | h: ${h} | dist: ${dist2}`);
            // if(h < dist2){
            if(h-dist2 < 1){
                if(t != ''){console.log(`${t} ‚Üí CollisionCheck(${a.id},${b.id});`);console.log(` ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ `);}
                console.log(`a.x = ${a.x} | b.x = ${b.x} | a.y = ${a.y} | b.y = ${b.y} | \nh: ${h} | dist: ${dist2}`);
                let collision_angle = XYtoAngle(x2,y2);
                ContinualCollisionUpdate3(a,b,h,collision_angle);

                // collisionUpdate(a,b);
                // collisionUpdate(b,a);
                // // speedCount();
                // // CollisionLog();
                // setTimeout(() => {
                //     CollisionLog();
                // }, "500");
            }
        }
        const adjecentSectors3 = [[0,1],[1,-1],[1,0],[1,1]];
        function SectorCheck3(){
            // console.log(`SectorCheck3()`);
            let sectorList = Object.keys(sector);
            let filteredSectors = [];
            if(sectorList.length > 0) {
                for(let i = 0; i < sectorList.length; i++){
                    let keys = Object.keys(sector[sectorList[i]]);
                    if(keys.length > 0){
                        // filteredSectors.push(sector[sectorList[i]]);
                        filteredSectors.push(sectorList[i]);
                        SectorCheck3_EachSector(sector[sectorList[i]]);
                    }
                }
            }
            // console.log(filteredSectors);
            // // console.log(`filteredSectors.length: ${filteredSectors.length}`);
            // // SectorCheck3_EachSector(filteredSectors);
            SectorCheck3_Adjacent(filteredSectors);
            // console.log(` ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ `);
        }
        function SectorCheck3_EachSector(sectorList){
            // console.log(`SectorCheck3_EachSector()`);
            for(let i = 0; i < Object.keys(sectorList).length - 1; i++){
                let e1 = sectorList[Object.keys(sectorList)[i]];
                for(let j = i+1; j < Object.keys(sectorList).length; j++){
                    let e2 = sectorList[Object.keys(sectorList)[j]];
                    // collisionCheck(e1,e2);
                    CollisionCheck3(e1,e2,'EachSector');
                    // CollisionCheck3(e1,e2);
                }
            }
        }
        function SectorCheck3_Adjacent(filteredSectors){
            // console.log(`SectorCheck3_Adjacent()`);
            // console.log(`filteredSectors.length: ${filteredSectors.length}`);

            let sectorParings = [];
            if(filteredSectors.length > 1){
                filteredSectors.forEach(sectorKey => {
                    let y = parseInt(sectorKey.split(',')[1]);
                    let x = parseInt(sectorKey.split(',')[0]);
                    // -- Make a list of sectors in the adjacent positions: [[0,1],[1,-1],[1,0],[1,1]]
                    adjecentSectors3.forEach(adj => {
                        let adj_y = y + adj[0];
                        let adj_x = x + adj[1];
                        let adj_k = `${adj_x},${adj_y}`;
                        // -- Check if the adjacent sectors are in our list of filteredSectors.
                        if(filteredSectors.includes(adj_k)){
                            // -- If they are, we found a sector paring for comparison. We add them (the current sector, and the adjacent sector that is in the filteredSectors list) to a list of `sectorParings`
                            sectorParings.push([sectorKey, adj_k]);
                        }
                    });
                });
            }
            // We iterate the list of sectorPairings
            // -- (We check each pairing on sectorPairings for the particle parings.)
            if(sectorParings.length > 0){
                sectorParings.forEach(pair => {
                    let s1 = sector[pair[0]];
                    let s2 = sector[pair[1]];
                    // -- Each particle on a sector is compared to the particles on the other sector. Calling the `CompareParticles(a,b)`.
                    Object.keys(s1).forEach(k1 =>{
                        Object.keys(s2).forEach(k2 =>{
                            // console.log(`Adjecent ‚Üí collisionCheck(${k1},${k2});`)
                            // collisionCheck(s1[k1],s2[k2]);
                            CollisionCheck3(s1[k1],s2[k2],'Adjacent');
                        });
                    });
                });
            }
            // console.log(` ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ `);
        }

        function SectorCheck3_Original(){
            console.log(`SectorCheck3()`);
            let sectorList = Object.keys(sector);
            if(sectorList.length > 0) {
                // console.log(`sectorList: [${sectorList.join()}]`);

                let filteredSectors = [];
                if(sectorList.length > 1) {
                    for(let i = 0; i < sectorList.length; i++){
                        let keys = Object.keys(sector[sectorList[i]]);
                        if(keys.length > 0){
                            // filteredSectors.push(sector[sectorList[i]]);
                            filteredSectors.push(sectorList[i]);
                        }
                    }
                }
                // console.log(`filteredSectors: [${filteredSectors.join(';')}]`);
                console.log(filteredSectors);

                let sectorParings = [];
                if(filteredSectors.length > 1){
                    filteredSectors.forEach(sectorKey => {
                        // console.log(`sectorKey: ${sectorKey}`);
                        let y = parseInt(sectorKey.split(',')[1]);
                        let x = parseInt(sectorKey.split(',')[0]);
                        // console.log(`x: ${x}, y: ${y}`);
                        // -- Make a list of sectors in the adjacent positions: [[0,1],[1,-1],[1,0],[1,1]]
                        adjecentSectors3.forEach(adj => {
                            let adj_y = y + adj[0];
                            let adj_x = x + adj[1];
                            // let adj_k = `${adj_y},${adj_x}`;
                            let adj_k = `${adj_x},${adj_y}`;
                            // console.log(`adj_k: ${adj_k}`);
                            // -- Check if the adjacent sectors are in our list of filteredSectors.
                            if(filteredSectors.includes(adj_k)){
                                // -- If they are, we found a sector paring for comparison. We add them (the current sector, and the adjacent sector that is in the filteredSectors list) to a list of `sectorParings`
                                sectorParings.push([sectorKey, adj_k]);
                            }
                            //else if(sector[`${adj_y},${adj_x}`].length > 0){
                            //    sectorPairings.push(sectorKey);
                            //}
                        });
                    });
                }
                // console.log(`sectorParings: [${sectorParings.join(';')}]`);
                // console.log(sectorParings);

                // We iterate the list of sectorPairings
                // -- (We check each pairing on sectorPairings for the particle parings.)
                if(sectorParings.length > 0){
                    sectorParings.forEach(pair => {
                        let s1 = sector[pair[0]];
                        let s2 = sector[pair[1]];
                        // -- Each particle on a sector is compared to the particles on the other sector. Calling the `CompareParticles(a,b)`.
                        // let s1ks = Object.keys(s1);
                        // let s2ks = Object.keys(s2);
                        Object.keys(s1).forEach(k1 =>{
                            // let p1 = s1[k1];
                            Object.keys(s2).forEach(k2 =>{
                                // let p2 = s2[k2];
                                // collisionCheck(p1,p2);
                                console.log(`collisionCheck(${k1},${k2});`)
                                collisionCheck(s1[k1],s2[k2]);
                            });
                        });
                    });
                }
                console.log(` ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ `);
            }
        }

        function speedCount(){
            let timeStyle = 'background-color: #00AAAA; color: white; font-size: 1em; border-radius: .25rem; font-weight: bold; padding: .25rem .5rem;';
            printSpeeds();
            let total_speed = 0;
            particles.forEach(p => {
                total_speed += p.speed ** 2;
            });
            // console.log(` \n total_speed: ${total_speed} \n\t\t\t\t\t‚è±`);
            // let style = 'background-color: #00AAAA; color: white; font-size: 1em; font-weight: bold';
            // console.log(`‚è± total_speed: ${total_speed.toFixed(4)}`);
            // console.log("%cHooray", style);
            // let style = 'background-color: #00AAAA; color: white; font-size: 1em; border-radius: .25rem; font-weight: bold; padding: .25rem .5rem;';
            // console.log(`‚è± total_speed: %c${total_speed.toFixed(4)}`, style);
            console.log(`‚è± total_speed: %c${total_speed.toFixed(4)}`, timeStyle);

            // console.log(sector);
        }

        function printSpeeds(){
            // let ps = {};
            let tStyle = 'background-color: #12b5cb; color: black; font-size: 1em; border-radius: .25rem; font-weight: bold; padding: .125rem .25rem;';
            particles.forEach(p => {
                // total_speed += p.speed ** 2;
                // console.log(`${p.id}‚è±‚Üí p.speed: ${p.speed.toFixed(4)}`);
                let psp = p.speed * 10;
                let pspt = Math.round(psp);
                // console.log(`${p.id}‚è±‚Üí p.speed: ${psp.toFixed(2)} ${'.'.repeat(pspt)}`);
                
                console.log(`${p.id}‚è±‚Üí p.speed: %c${psp.toFixed(2)}${' .'.repeat(pspt)}`, tStyle);
                // ps.push([p.speed]);
                // ps[p.id] = p.speed.toFixed(4);
            });
            // console.log(ps);
            // console.table(ps);
        }


        function start2(){
            // for (let index = 0; index < 6; index++) {
            //     // particles.push(new Particle(id = index, speed = 1));
            //     // particles.push(new Particle(id = index, speed = 3));
            //     // particles.push(new Particle(id = index, speed = index));
            //     // particles.push(new Particle(id = index, speed = 10));
            //     let sp = index/6;
            //     particles.push(new Particle2(id = index, speed = sp));
            // }

            // particles.push(new Particle2(id = 0, speed = 1));
            // particles.push(new Particle2(id = 1, speed = 1));

            // particles.push(new Particle2(id = 0, speed = 1, xyd = [120,100,45]));
            // particles.push(new Particle2(id = 1, speed = 0, xyd = [250,250,0]));

            // particles.push(new Particle2(id = 0, speed = .5));
            // particles.push(new Particle2(id = 1, speed = .5));

            // particles.push(new Particle2(id = 0, speed = 0, xyd = [120,220,0]));
            // particles.push(new Particle2(id = 1, speed = 0, xyd = [190,220,0]));
            // particles.push(new Particle2(id = 2, speed = 0.5, xyd = [350,220,180]));

            // /* particle moving horizontally */
            // particles.push(new Particle2(id = 0, speed = 1, xyd = [150,250,0]));
            // particles.push(new Particle2(id = 1, speed = 0, xyd = [250,250,0]));
            
            // /* particle moving horizontally, slightly off */
            // particles.push(new Particle2(id = 0, speed = 1, xyd = [150,260,0]));
            // particles.push(new Particle2(id = 1, speed = 0, xyd = [250,250,0]));

            // /* particle moving horizontally, barely touching */
            // particles.push(new Particle2(id = 0, speed = 1, xyd = [150,269,0]));
            // particles.push(new Particle2(id = 1, speed = 0, xyd = [250,250,0]));

            // /* particle moving horizontally, slightly off center */
            // particles.push(new Particle2(id = 0, speed = 1, xyd = [150,245,0]));
            // particles.push(new Particle2(id = 1, speed = 0, xyd = [250,250,0]));

            // // /* particle moving horizontally, pushing one another */
            // particles.push(new Particle2(id = 0, speed = 1, xyd = [150,245,0]));
            // particles.push(new Particle2(id = 1, speed = .25, xyd = [250,250,0]));

            // // /* particle moving horizontally, in direction to eachother */
            // particles.push(new Particle2(id = 0, speed = 1, xyd = [150,245,0]));
            // particles.push(new Particle2(id = 1, speed = .25, xyd = [250,250,180]));

            // // /* particle moving horizontally, directly to eachother */
            // particles.push(new Particle2(id = 0, speed = 1, xyd = [150,250,0]));
            // particles.push(new Particle2(id = 1, speed = .25, xyd = [250,250,180]));


            speedCount();
        }
        
        function start(){
            // for (let index = 0; index < 6; index++) {
            //     // particles.push(new Particle(id = index, speed = 1));
            //     // particles.push(new Particle(id = index, speed = 3));
            //     // particles.push(new Particle(id = index, speed = index));
            //     // particles.push(new Particle(id = index, speed = 10));
            //     let sp = index/6;
            //     particles.push(new Particle3(id = index, speed = sp));
            // }


            // /* particle moving horizontally */
            // particles.push(new Particle3(id = 0, speed = 1, xyd = [150,250,0]));
            // particles.push(new Particle3(id = 1, speed = 0, xyd = [250,250,0]));

            // /* particle moving horizontally, to a 45 collision angle. */
            // particles.push(new Particle3(id = 0, speed = 1, xyd = [380,264.142,0]));
            // particles.push(new Particle3(id = 1, speed = 0, xyd = [450,250,0]));
            
            // /* particle moving horizontally, slightly off */
            // particles.push(new Particle3(id = 0, speed = 1, xyd = [150,260,0]));
            // particles.push(new Particle3(id = 1, speed = 0, xyd = [250,250,0]));

            // /* particle moving horizontally, barely touching */
            // particles.push(new Particle3(id = 0, speed = 1, xyd = [150,269,0]));
            // particles.push(new Particle3(id = 1, speed = 0, xyd = [250,250,0]));

            // /* particle moving horizontally, slightly off center */
            // particles.push(new Particle3(id = 0, speed = 1, xyd = [150,245,0]));
            // particles.push(new Particle3(id = 1, speed = 0, xyd = [250,250,0]));

            // // /* particle moving horizontally, pushing one another */
            // particles.push(new Particle3(id = 0, speed = 1, xyd = [150,245,0]));
            // particles.push(new Particle3(id = 1, speed = .25, xyd = [250,250,0]));

            // // /* particle moving horizontally, in direction to eachother */
            // particles.push(new Particle3(id = 0, speed = 1, xyd = [150,245,0]));
            // particles.push(new Particle3(id = 1, speed = .25, xyd = [250,250,180]));

            // // /* particle moving horizontally, directly to eachother */
            // particles.push(new Particle3(id = 0, speed = 1, xyd = [150,250,0]));
            // particles.push(new Particle3(id = 1, speed = .25, xyd = [250,250,180]));

            /* particle moving diagonally, to a 0deg collision angle. */
            particles.push(new Particle3(id = 0, speed = .5, xyd = [230,260,315]));
            particles.push(new Particle3(id = 1, speed = .5, xyd = [270,240,135]));
            
            // a.x:230, a.y:260
            // b.x:270, b.y:240


            speedCount();
        }
        start();
        function handleParticles(){
            // pairing(particles);
            // sectorCheck();
            SectorCheck3();
            for (let index = 0; index < particles.length; index++) {
                const element = particles[index];
                element.update();
                element.draw();
            }
            // if(!s.pause){
            //     pairing(particles);
            // // }
            // // if(!s.pause){
            //     for (let index = 0; index < particles.length; index++) {
            //         const element = particles[index];
            //         element.update();
            //         element.draw();
            //     }
            // }
            // for (let index = 0; index < particles.length; index++) {
            //     const element = particles[index];
            //     if(!s.pause){
            //         element.update();
            //     }
            //     element.draw();
            // }
        }
        function animate (){
            // ctx.clearRect(0,0,canvas.width, canvas.height);
            // ctx.fillStyle = '#0002';
            // ctx.fillStyle = '#00000008';
            // ctx.fillStyle = '#00000004';
            // ctx.fillStyle = '#000000ff';
            // ctx.fillStyle = '#00000022';
            // ctx.fillRect(0, 0, canvas.width, canvas.height);
            if(!s.pause){
                // ctx.fillStyle = '#00000022';
                // ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.clearRect(0,0,canvas.width, canvas.height);
                handleParticles();
            }
            // hueHelix();
            // handleParticles();
            requestAnimationFrame(animate);
        }
        // animate();

        function q(){
            s.q ? s.q = false : s.q = true;
            console.log(`q = ${s.q}.`);
        }
        function pause(){
            // s.pause ? s.pause = false : s.pause = true;
            // console.log(`pause = ${s.pause}.`);
            if(!s.q){
                s.pause ? s.pause = false : s.pause = true;
                console.log(`pause = ${s.pause}.`);
            }
        }
        window.addEventListener("keydown", function (event) {
            // console.log(`key: '${event.key}', keyCode: '${event.keyCode}'.`);
            if(event.key == ' ') {
                // s.pause ? s.pause = false : s.pause = true;
                // console.log(`pause = ${s.pause}.`);
                pause();
            }
            if(event.key == 'Escape') {
                // s.pause ? s.pause = false : s.pause = true;
                // console.log(`pause = ${s.pause}.`);
                q();
            }
        });
    

        
        // window.addEventListener('mousemove', (ev) =>{
        //     // let chance = Math.floor(Math.random()*100) + 1;
        //     s.x = ev.clientX;
        //     s.y = ev.clientY;
        //     // hueHelix();
        // });
        // function zoom(event) {
        //     event.preventDefault();
        //     scale += event.deltaY * -0.01;
        //     scale = Math.min(Math.max(.125, scale), 4);
        //     s.z = (scale * 10)+20;
        // }
        // let scale = 1;
        // const el = document.querySelector('#canvas');
        // el.onwheel = zoom;

        var memoryStates = {};
        var memKeys = ['id','x','y','sid','speed','dx','dy','d','path','forceQueue'];
        function MemoryUpdate(){
            // particles.forEach(p => {
            //     let pid = `p${p.id}`;
            //     if(!Object.keys(p).includes(pid)){
            //         memoryStates[pid] = {};
            //     }
            //     Object.keys(p).forEach(k => {
            //         memoryStates[pid][k] = p[k];
            //     });
            // });
            particles.forEach(p => {
                let pid = `p${p.id}`;
                if(!Object.keys(p).includes(pid)){
                    memoryStates[pid] = {};
                }

                memKeys.forEach(k => {
                    if(typeof p[k] == 'object'){
                        memoryStates[pid][k] = p[k].flat().join();
                    } else {
                        memoryStates[pid][k] = p[k];
                    }
                });
            });
        }

        function CheckSpeed(){
            let sum = 0;
            particles.forEach(p => {
                sum += p.speed ** 2;
            });
            return sum;
        }

        var initialSpeed = 0;
        window.addEventListener('load', (ev) => {
            console.log(`Welcome to my Lab!`);
            DrawGrid(ctx_bg);
            // start();
            initialSpeed = CheckSpeed();
            particles.forEach(p => {
                p.tpsp = initialSpeed;
            });
            console.log(`Initial Total Speed: ${initialSpeed}.`);
            MemoryUpdate();

            animate();
            // console.log(`After animate.`);
        });

        /*
        This is what I need to do:
        
        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
        ‚ñà‚ñà/////////‚îÇ//‚ñà‚ñà  ‚îÇ      ‚îÇ  ‚ñà‚ñà\\‚îÇ\\\\\\\\\‚ñà‚ñà
        ‚ñà‚ñà/////////‚îÇ//‚ñà‚ñà  ‚îÇ      ‚îÇ  ‚ñà‚ñà\\‚îÇ\\\\\\\\\‚ñà‚ñà
        ‚ñà‚ñà////////x‚îÇ//‚ñà‚ñà  ‚îÇ      ‚îÇ  ‚ñà‚ñà\\‚îÇ\\\\\\\\\‚ñà‚ñà
        ‚ñà‚ñà‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚ñà‚ñà‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚ñà‚ñà‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñà‚ñà
        ‚ñà‚ñà/////////‚îÇ//‚ñà‚ñà  ‚îÇ      ‚îÇ  ‚ñà‚ñà\\‚îÇ\\\\y\\\\‚ñà‚ñà
        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
        ‚ñà‚ñà         ‚îÇ  ‚ñà‚ñà  ‚îÇ      ‚îÇ  ‚ñà‚ñà\\‚îÇ\\\\\\\\\‚ñà‚ñà
        ‚ñà‚ñà‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚ñà‚ñà‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚ñà‚ñà‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñà‚ñà
        ‚ñà‚ñà         ‚îÇ  ‚ñà‚ñà  ‚îÇ      ‚îÇ  ‚ñà‚ñà  ‚îÇ         ‚ñà‚ñà
        ‚ñà‚ñà‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚ñà‚ñà‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚ñà‚ñà‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñà‚ñà
        ‚ñà‚ñà¬¶¬¶¬¶¬¶¬¶¬¶¬¶¬¶¬¶‚îÇ¬¶¬¶‚ñà‚ñà¬¶¬¶‚îÇ      ‚îÇ  ‚ñà‚ñà  ‚îÇ         ‚ñà‚ñà
        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
        ‚ñà‚ñà¬¶¬¶¬¶¬¶¬¶¬¶¬¶¬¶¬¶‚îÇz ‚ñà‚ñà¬¶¬¶‚îÇ      ‚îÇ  ‚ñà‚ñà  ‚îÇ         ‚ñà‚ñà
        ‚ñà‚ñà‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚ñà‚ñà‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚ñà‚ñà‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñà‚ñà
        ‚ñà‚ñà¬¶¬¶¬¶¬¶¬¶¬¶¬¶¬¶¬¶‚îÇ¬¶¬¶‚ñà‚ñà¬¶¬¶‚îÇ      ‚îÇ  ‚ñà‚ñà  ‚îÇ         ‚ñà‚ñà
        ‚ñà‚ñà¬¶¬¶¬¶¬¶¬¶¬¶¬¶¬¶¬¶‚îÇ¬¶¬¶‚ñà‚ñà¬¶¬¶‚îÇ      ‚îÇ  ‚ñà‚ñà  ‚îÇ         ‚ñà‚ñà
        ‚ñà‚ñà¬¶¬¶¬¶¬¶¬¶¬¶¬¶¬¶¬¶‚îÇ¬¶¬¶‚ñà‚ñà¬¶¬¶‚îÇ      ‚îÇ  ‚ñà‚ñà  ‚îÇ         ‚ñà‚ñà
        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

        so the collisions are not checked for all particles, only for their sectors and the small area that goes around the sectors.

        var sides = {2:[1,0],4:[0,-1],6:[0,1],8:[-1,0]};
        */
        function PrintPath3(ob, sp = ' '){
            let path = '';
            let space = `${sp} ‚îú`;
            let space2 = `${sp} ‚îÇ`;
            let keys = Object.keys(ob);
            for (let i = 0; i < keys.length; i++) {
                const k = keys[i];
                if(i == keys.length-1) {space = `${sp} ‚îî`; space2 = `${sp}  `;}
                if(typeof ob[k] == 'object'){
                    path += `${space}‚îÄ${k}:\n`;
                    path += PrintPath3(ob[k], space2);
                } else {path += `${space}‚îÄ${k}: ${ob[k]}\n`;}
            }
            return path;
        }
        function PrintObj3(ob, name = 'ob'){
            let path = `‚Ä¢[${name}]\n`;
            let space = '‚îú';
            let space2 = '‚îÇ';
            let keys = Object.keys(ob);
            for (let i = 0; i < keys.length; i++) {
                const k = keys[i];
                if(i == keys.length-1) {space = '‚îî'; space2 = ' ';}
                if(typeof ob[k] == 'object'){
                    path += `${space}‚îÄ${k}:\n`;
                    path += PrintPath3(ob[k], space2);
                } else {path += `${space}‚îÄ${k}: ${ob[k]}\n`;}
            }
            console.log(path);
        }

        function PrintPath(ob){
            let rootStyle = 'background-color: #d2c057; color: #000000; border-radius: .25rem; padding: .125rem .25rem;';
            let pipeStyle = 'color: #d2c057;';
            let leafStyle = 'background-color: #55FF55; color: #000000; border-radius: .25rem; padding: .125rem .25rem;';
            let space = `‚îú`;
            let keys = Object.keys(ob);
            for (let i = 0; i < keys.length; i++) {
                const k = keys[i];
                if(i == keys.length-1) {space = `‚îî`;}
                if(typeof ob[k] == 'object'){
                    // let gp = `%c${space}‚îÄ${k}:`;
                    // console.group(gp, pipeStyle);
                    let gp = `%c${space}‚îÄ%c${k}:`;
                    console.group(gp, pipeStyle, rootStyle);
                    PrintPath(ob[k]);
                    console.groupEnd(gp);
                } else {console.info(`%c${space}‚îÄ%c${k}: ${ob[k]}`, pipeStyle, leafStyle);}
            }
        }
        function PrintObj(ob, name = 'ob'){
            let rootStyle = 'background-color: #d2c057; color: #000000; border-radius: .25rem; font-weight: bold; padding: .125rem .25rem;';
            let pipeStyle = 'color: #d2c057;';
            let leafStyle = 'background-color: #55FF55; color: #000000; border-radius: .25rem; padding: .125rem .25rem;';
            let path = `%c‚Ä¢[${name}]`;
            console.group(path, rootStyle);
            let space = '‚îú';
            let keys = Object.keys(ob);
            for (let i = 0; i < keys.length; i++) {
                const k = keys[i];
                if(i == keys.length-1) {space = '‚îî';}
                if(typeof ob[k] == 'object'){
                    let gp = `%c${space}‚îÄ%c${k}:`;
                    console.group(gp, pipeStyle, rootStyle);
                    PrintPath(ob[k]);
                    console.groupEnd(gp);
                } else {
                    console.info(`%c${space}‚îÄ%c${k}: ${ob[k]}`, pipeStyle, leafStyle);
                }
            }
            console.groupEnd(path);
        }
    </script>
</body>
</html>