<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="https://raw.githubusercontent.com/UserStefDLT/WebResources/master/Images/icon_st.png">
    <title>Fireworks 2 | NyteLabs</title>
    <link rel="stylesheet" href="../../../stylesheets/start.css">
    <link rel="stylesheet" href="../../../stylesheets/labst.css">
    <link rel="stylesheet" href="../../../stylesheets/radio-nav.css">
    <link rel="stylesheet" href="../../../stylesheets/deck.css">
    <link rel="stylesheet" href="../../../stylesheets/canvas.css">
    <style>
    </style>
    <link rel="stylesheet" href="../../../stylesheets/end.css">
</head>
<body>
    <header>
        <a href="../../../index.html" class="backLink"><div class="backBtn">Back?</div></a>
        <div class="title">Fireworks 2</div>
        <!-- <div class="subtitle">mouse effects (previously in canvas 04 - 07)</div> -->
    </header>

<main>
    <div class="shelf">
        <!-- <div class="shelf-title">title</div> -->
        <canvas id="canvas"></canvas>
    </div>
</main>


<footer>
    <div class="my-name">
        <a href="#">Back To Top</a>
        &copy; 2022 | by Stéfano De La Torre 
    </div>
</footer>
<div class="name-end">by St&eacute;fano.</div>
<!-- <script src="main.js"></script> -->
<script>
    /* Constant Variables */
    const s = {
        h: window.innerHeight,
        w: window.innerWidth,

        touch: {
            x: 0,
            y: 0,
            z: 0,
            paths: {},
            path_len: 20,
            tracking: false
        },
        mouse: {
            x: 0,
            y: 0,
            z: 0,
            path: [],
            path_len: 20,
            tracking: false
        },
        tile: {
            h: 20,
            w: 20,
            sz: 20,
            sz2: 10,
            margin: 16,
            fill: 0
        },
        grid: {
            h: window.innerHeight,
            w: window.innerWidth,
            cols: 15,
            rows: 15,
            margin: 24
        },
        canvas: {
            h: window.innerHeight,
            w: window.innerWidth,
            padding: 0,
            brush: "p",
        },
        box: {
            x: 500,
            y: 500,
            z: 500,
            x2: 250,
            y2: 250,
            z2: 250,
            d: 1000,
            p: 1000,
        },
        rotate: {
            degs: 5,
        },
        rotating: {
            xdegs: 0,
            ydegs: 0,
        },
        view: {
            idx: -1,
            x: -1,
            y: -1,
        },
        

        timeOut: 40,
        player: false,
        
        s: false,
        steps: false,
        tags: false,
        log: true,
        lockKeys: false,
        pause: false,
        q: false
    }
    const particles = [];
    const pg = {}

</script>
<script src="../../../scripts/settings.js"></script>
<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    window.addEventListener('resize', () =>{
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        s.x = window.innerWidth/2;
        s.y = window.innerHeight/2;

        s.midX = window.innerWidth/2;
        s.midY = window.innerHeight/2;
    });

    const click_particles = [];
    const mouse_particles = [];
    // const s = {
    //     x: 0,
    //     y: 0,

    //     r: 3,
    //     c: 0,
    //     hue: 0,
    //     hue_steps: 6,
    //     hue_step: 360/6,
    //     lum_step: 20,
    //     z: 30
    // }

    function draw_z(ctx,e){
        if(e.x > 0 && e.x < (s.w) && e.y > 0 && e.y < (s.h)){
            e.getSize();
            ctx.fillStyle = e.getColor();
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.size_z/2, 0, Math.PI * 2);
            ctx.fill();
        } 
    }


    // function zoom(event) {
    //     event.preventDefault();
    //     scale += event.deltaY * -0.01;
    //     scale = Math.min(Math.max(.125, scale), 4);
    //     s.z = (scale * 10)+20;
    // }
    // let scale = 1;
    // // const el = document.querySelector('#canvas');
    // canvas.onwheel = zoom;


    const s2 = {
        x: 0,
        y: 0,
        
        r: 3,
        c: 0,
        hue: 0,
        hue_steps: 6,
        hue_step: 360/6,
        lum_step: 20,
        z: 30
    }
    function hueHelix(){
        let chance = Math.floor(Math.random()*100) + 1;
        // let hue_add = Math.floor(Math.random()*2) + 1;
        let hue_add = 1;
        s.hue = s.hue + hue_add;
        if(chance > 0){
            for (let index = 0; index < s.hue_steps; index++) {
                let hue = s.hue + (index * s.hue_step);
                let dotOff = (Math.floor(Math.random()*s.z) + 20);
                let radius = Math.floor(Math.random()*s.r) + 1;
                let lum = dotOff - 10;

                let cirX = Math.cos(Math.PI*(hue/180)) * dotOff;
                let cirY = Math.sin(Math.PI*(hue/180)) * dotOff;
                let x = cirX + s.x;
                let y = cirY + s.y;
        
                ctx.fillStyle = `hsl(${hue}, 100%, ${lum}%)`;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    class Particle {
        constructor(){
            // this.x = s.x;
            // this.y = s.y;
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.hue = Math.random() * 360;
            // this.hueSp = Math.random() * 3;
            this.hueSp = Math.random() + .5;
            
            this.hueOff = Math.random() * 300;

            // this.size = Math.random() * 5 + 1;
            // this.size = Math.random() * 5 + 5;
            this.size = Math.random() * 2 + .1;
            this.spX = Math.random() * 3 - 1.5;
            this.spY = Math.random() * 3 - 1.5;
        }
        update(){
            // this.x += this.spX;
            // this.y += this.spY;

            let cirX = Math.cos(Math.PI*(this.hue/180)) * this.hueOff;
            let cirY = Math.sin(Math.PI*(this.hue/180)) * this.hueOff;
            // let xGo = cirX + s.x;
            // let yGo = cirY + s.y;
            this.x = cirX + s.x;
            this.y = cirY + s.y;

            // if(this.y > canvas.height || this.x > canvas.width || this.y < 0 || this.x < 0){
            //     this.x = Math.random() * (canvas.width/2) + (canvas.width/4);
            //     this.y = Math.random() * (canvas.height/2) + (canvas.height/4);
            // }

            // this.size += Math.random() * 2 - 1;
            if(this.size < 2) this.size += 1;
            if(this.size > 5) this.size -= 1;

            this.hue += this.hueSp;
            if(this.hue > 360) this.hue -= 360;
        }
        draw(){
            // ctx.fillStyle = '#f398';
            ctx.fillStyle = `hsl(${this.hue}, 100%, 40%)`;
            // ctx.fillStyle = `hsl(60, 100%, 40%)`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    class Spark {
        constructor(){
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.angle = Math.random() * 360;
            this.rotSp = Math.random() + .5;
            this.radius = Math.random() * 50;
            this.entropy = Math.random() * 2 + 1;
            this.rlimit = 100;
            
            this.hue = 60;
            this.sat = 100;
            this.lum = 60;
            this.alp = 1;

            this.size = Math.random() * 2 + .1;
            this.spX = Math.random() * 3 - 1.5;
            this.spY = Math.random() * 3 - 1.5;
        }
        update(){
            let sizeLim = 5;
            let hueRange = 60;

            this.radius += this.entropy;
            if(this.radius > this.rlimit) {
                this.radius = Math.random() * 3 + 2;
                this.angle = Math.random() * 360;
            }
            this.alp = Math.floor(100 - (this.radius/(this.rlimit/100)))/100;
            this.hue = Math.floor(hueRange - (this.radius/(this.rlimit/hueRange)));
            this.size = Math.floor(sizeLim - (this.radius/(this.rlimit/sizeLim))) + .5;
            
            let gravity = 10;

            let cirX = Math.cos(Math.PI*(this.angle/180)) * this.radius;
            let cirY = Math.sin(Math.PI*(this.angle/180)) * this.radius;

            this.x = cirX + s.x;
            this.y = cirY + s.y;
            // this.y = cirY + s.y + (this.gravity * this.radius);

            // this.angle += this.rotSp;
            if(this.angle > 360) this.angle -= 360;
        }
        draw(){
            ctx.fillStyle = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    class FireWorks {
        constructor(){
            // this.x = s.x;
            // this.y = s.y;
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.angle = Math.random() * 360;
            this.rotSp = Math.random() + .5;
            // this.radius = Math.random() * 50;
            this.radius = Math.random() * 5;
            // this.entropy = Math.random() * 2 + 1;
            // this.entropy = Math.random() * 1 + .5;
            
            this.time = 100;
            this.entropy = .5;
            
            this.hue = 0;
            this.sat = 100;
            this.lum = 60;
            this.alp = 1;
            
            this.sizeLim = 3;
            this.hueStart = 180;
            // this.hueRange = 60;
            this.hueRange = 180;
            this.hueRange = 360;
            this.radius_limit = 200;

            this.size = Math.random() * 2 + .1;
            this.spX = Math.random() * 3 - 1.5;
            this.spY = Math.random() * 3 - 1.5;
        }
        update(){
            this.time -= this.entropy;
            if(this.time < 1){
                this.time = 100;
                this.angle = Math.random() * 360;
                this.radius = Math.random() * 3 + 2;
            }
            let timef = this.time / 100;
            let timefs = 1-(this.time / 100);
            this.radius = (timefs * 200) + 10;

            // this.radius += this.entropy * 2;
            // if(this.radius > this.radius_limit) {
            //     this.radius = Math.random() * 3 + 2;
            //     this.angle = Math.random() * 360;
            // }
            let radius_percent = this.radius / this.radius_limit;
            // this.alp = Math.floor(100 * (1 - radius_percent))/100;
            // this.hue = Math.floor(this.hueRange * (1-radius_percent)) + this.hueStart;
            // this.size = this.sizeLim * (1-radius_percent) + 1;
            
            // this.alp = Math.floor(100 * timefs)/100;
            this.alp = Math.floor(((3*(1 - timefs)**2) * timefs)*100)/100;
            this.hue = Math.floor(this.hueRange * this.alp) + this.hueStart;
            this.size = this.sizeLim * timefs + 1;
            
            let rr = radius_percent;
            let gravity = (rr * rr) * (this.radius_limit / 5);

            let cirX = Math.cos(Math.PI*(this.angle/180)) * this.radius;
            let cirY = Math.sin(Math.PI*(this.angle/180)) * this.radius;
            this.x = cirX + s.x;
            // this.y = cirY + s.y;
            this.y = cirY + s.y + gravity;

            // if(this.y > canvas.height || this.x > canvas.width || this.y < 0 || this.x < 0){
            //     this.x = Math.random() * (canvas.width/2) + (canvas.width/4);
            //     this.y = Math.random() * (canvas.height/2) + (canvas.height/4);
            // }

            // this.size -= Math.random() * .2;
            // this.size -= .01;
            if(this.size < .5) this.size = .5;
            if(this.size > 5) this.size -= 1;

            // this.angle += this.rotSp;
            // if(this.angle > 360) this.angle -= 360;
        }
        draw(){
            // ctx.fillStyle = '#f398';
            // ctx.fillStyle = `hsl(${this.hue}, 100%, 40%)`;
            // ctx.fillStyle = `hsl(60, 100%, 40%)`;
            // ctx.filter = `drop-shadow(15px 15px 15px hsla(${hue}, ${sat}%, ${lum_shadow}%, ${alp-.5})) blur(5px) url(#cloud)`;
            // ctx.filter = `drop-shadow(15px 15px 15px hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${alp_shadow})) blur(5px)`;
            // let lum_shadow = this.lum/2;
            // let alp_shadow = this.alp/2;
            // ctx.filter = `drop-shadow(0px 0px 5px hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${alp_shadow}))`;

            
            ctx.fillStyle = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    class FireWorks2 {
        constructor(id, count){
            this.id = id;
            this.nodeCount = count;
            this.depth = (this.id / this.nodeCount);
            this.xc = s.x;
            this.yc = s.y;
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.angle = Math.random() * 360;
            this.angleZ = Math.random() * 360;
            this.rotSp = Math.random() + .5;
            this.radius = Math.random() * 5;

            this.time = 100;
            this.entropy = .5;
            
            this.hue = 0;
            this.sat = 100;
            this.lum = 60;
            this.alp = 1;
            
            this.sizeLim = 2;
            this.hueStart = Math.random() * 20 - 10;
            this.hueRange = 60;
            this.hueRange = 360;
            this.radius_limit = 200;

            this.size = Math.random() * 2 + .1;
            this.spX = Math.random() * 3 - 1.5;
            this.spY = Math.random() * 3 - 1.5;
        }
        update(){
            this.time -= this.entropy;
            if(this.time < 1){
                this.time = 0;
                this.angle = Math.random() * 360;
                this.angleZ = Math.random() * 360;
            }
            let timef = this.time / 100;
            let timefs = 1-(this.time / 100);
            this.radius = (timefs * 200) + 5;

            let radius_percent = this.radius / this.radius_limit;

            this.alp = Math.floor(((3*(1 - timefs)**2) * timefs)*100)/100;
            this.hue = Math.floor(this.hueRange * this.alp) + this.hueStart;
            this.size = this.sizeLim * timefs + 1;
            
            let gravity = (timefs * timefs) * (this.radius_limit / 3);

            this.lum = 10 + (this.depth*50);

            let cirZx = Math.cos(Math.PI*(this.angleZ/180));
            let cirX = Math.cos(Math.PI*(this.angle/180)) * this.radius * cirZx;
            let cirY = Math.sin(Math.PI*(this.angle/180)) * this.radius;
            this.x = cirX + this.xc;
            this.y = cirY + this.yc + gravity;

        }
        draw(){
            ctx.fillStyle = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    class FireWorks3 {
        constructor(id, count, hue){
            this.id = id;
            this.nodeCount = count;
            this.depth = (this.id / this.nodeCount);
            this.xc = s.x;
            this.yc = s.y;
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.angle = Math.random() * 360;
            this.angleZ = Math.random() * 360;
            this.rotSp = Math.random() + .5;
            this.radius = Math.random() * 5;

            this.time = 100;
            this.entropy = .5;
            
            this.hue = hue;
            this.sat = 100;
            this.lum = 70;
            this.alp = 1;
            
            this.sizeLim = 2;
            this.hueStart = Math.random() * 20 - 10;
            // this.hueRange = 60;
            // this.hueRange = 360;
            // this.hue = Math.floor(Math.random() * 360);
            this.radius_limit = 200;

            this.size = Math.random() * 2 + .1;
            this.spX = Math.random() * 3 - 1.5;
            this.spY = Math.random() * 3 - 1.5;
        }
        update(){
            this.time -= this.entropy;
            if(this.time < 1){
                this.time = 0;
                this.angle = Math.random() * 360;
                this.angleZ = Math.random() * 360;
            }
            let timef = this.time / 100;
            let timefs = 1-(this.time / 100);
            this.radius = (timefs * 200) + 5;

            let radius_percent = this.radius / this.radius_limit;

            // this.alp = Math.floor(((3*(1 - timefs)**2) * timefs)*100)/100;
            // this.alp = Math.floor(timef%100);
            this.alp = timef;
            
            this.hue += Math.floor(Math.random() * 6 - 3);
            this.size = this.sizeLim * timefs + 1;
            
            let gravity = (timefs * timefs) * (this.radius_limit / 3);

            this.lum = 10 + (this.depth*50);

            let cirZx = Math.cos(Math.PI*(this.angleZ/180));
            let cirX = Math.cos(Math.PI*(this.angle/180)) * this.radius * cirZx;
            let cirY = Math.sin(Math.PI*(this.angle/180)) * this.radius;
            this.x = cirX + this.xc;
            this.y = cirY + this.yc + gravity;

        }
        draw(){
            ctx.fillStyle = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    class FireWorksMouse {
        constructor(id, count){
            this.id = id;
            this.nodeCount = count;
            this.depth = (this.id / this.nodeCount);
            this.xc = s.x;
            this.yc = s.y;
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.angle = Math.random() * 360;
            this.angleZ = Math.random() * 360;
            this.rotSp = Math.random() + .5;
            this.radius = Math.random() * 1;

            this.time = 50;
            this.entropy = 1;
            
            this.hue = 0;
            this.sat = 100;
            this.lum = 60;
            this.alp = 1;
            
            this.timeLim = 50;

            this.sizeLim = 2;
            this.sizeMin = .5;
            // this.hueStart = Math.random() * 10;
            this.hueStart = Math.random() * 10 + (this.xc + this.yc)%360;
            this.hueRange = 60;
            this.radiusLim = 50;
            this.radiusMin = 1;

            this.size = Math.random() * 2 + .1;
            this.spX = Math.random() * 3 - 1.5;
            this.spY = Math.random() * 3 - 1.5;
        }
        update(){
            this.time -= this.entropy;
            if(this.time < 1){
                this.time = 0;
                this.angle = Math.random() * 360;
                this.angleZ = Math.random() * 360;
            }
            let timef = this.time / this.timeLim;
            let timefs = 1-(this.time / this.timeLim);
            this.radius = (timefs * this.radiusLim) + this.radiusMin;

            // this.alp = Math.floor(((3*(1 - timefs)**2) * timefs)*100)/100;
            // this.alp = 1 - Math.floor((timef+.001)**-2)/100;
            // this.alp = 1 - Math.floor(timefs**5)/100;
            // this.alp = 1;
            this.alp = Math.floor(((3*timef**2) * timefs)*100)/100;
            this.hue = Math.floor(this.hueRange * timef) + this.hueStart;
            this.size = this.sizeLim * timefs + this.sizeMin;
            
            let gravity = (timefs * timefs) * (this.radiusLim / 3);

            this.lum = 10 + (this.depth*50);

            let cirZx = Math.cos(Math.PI*(this.angleZ/180));
            let cirX = Math.cos(Math.PI*(this.angle/180)) * this.radius * cirZx;
            let cirY = Math.sin(Math.PI*(this.angle/180)) * this.radius;
            this.x = cirX + this.xc;
            this.y = cirY + this.yc + gravity;

            // if(this.time == 0) {
            //     this.alp = 0;
            // }

        }
        draw(){
            ctx.fillStyle = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    class NebulaMouse {
        constructor(id, count){
            this.id = id;
            this.nodeCount = count;
            this.depth = (this.id / this.nodeCount);
            this.xc = s.x;
            this.yc = s.y;
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.angle = Math.random() * 360;
            this.angleZ = Math.random() * 360;
            this.rotSp = Math.random() + .5;
            this.radius = Math.random() * 1;

            this.time = 50;
            this.entropy = 1;
            
            this.hue = 0;
            this.sat = 100;
            this.lum = 60;
            this.alp = 1;
            
            this.timeLim = 50;

            this.sizeLim = 2;
            this.sizeMin = .5;
            // this.hueStart = Math.random() * 10;
            this.hueStart = Math.random() * 10 + (this.xc + this.yc)%360;
            this.hueRange = 60;
            this.radiusLim = 50;
            this.radiusMin = 1;

            this.size = Math.random() * 2 + .1;
            this.spX = Math.random() * 3 - 1.5;
            this.spY = Math.random() * 3 - 1.5;
        }
        update(){
            this.time -= this.entropy;
            if(this.time < 1){
                this.time = 0;
                this.angle = Math.random() * 360;
                this.angleZ = Math.random() * 360;
            }
            let timef = this.time / this.timeLim;
            let timefs = 1-(this.time / this.timeLim);
            // this.radius = (timefs * this.radiusLim) + this.radiusMin;

            this.angle += 2;
            if(this.angle > 360) this.angle -=360;
            this.radius = ((3*(1 - timefs) * (timefs**2)) * this.radiusLim) + this.radiusMin;

            // this.alp = Math.floor(((3*(1 - timefs)**2) * timefs)*100)/100;
            // this.alp = 1 - Math.floor((timef+.001)**-2)/100;
            // this.alp = 1 - Math.floor(timefs**5)/100;
            this.alp = 1;
            this.hue = Math.floor(this.hueRange * timef) + this.hueStart;
            this.size = this.sizeLim * timefs + this.sizeMin;
            
            let gravity = (timefs * timefs) * (this.radiusLim / 3);

            this.lum = 10 + (this.depth*50);

            let cirZx = Math.cos(Math.PI*(this.angleZ/180));
            let cirX = Math.cos(Math.PI*(this.angle/180)) * this.radius * cirZx;
            let cirY = Math.sin(Math.PI*(this.angle/180)) * this.radius;
            this.x = cirX + this.xc;
            this.y = cirY + this.yc + gravity;

            // if(this.time == 0) {
            //     this.alp = 0;
            // }

        }
        draw(){
            ctx.fillStyle = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    

    class pz2 {
        constructor(id, type="p", x, y, z, clr={}){
            // this.ctx = ctx;
            this.id = id;
            this.type = type;

            this.x = x;
            this.y = y;
            this.vx = 0;
            this.vy = 0;
            this.z = z;
            this.vz = 0;

            this.mass = 1;
            this.size = 2;
            this.size_z = this.size;
            this.size_range = 4;

            this.time = 100;
            this.entropy = 0.5;
            // this.hp = 100;
            // this.hpdown = .5;

            this.s = {"x":x,"y":y,"z":z,"size_z":this.size_z};
            this.rotating = {"x":0,"y":0,"z":0};

            this.hue = 210;
            this.sat = 100;
            this.lum = 50;
            this.alp = 1;
            this.alp = .5;
            if(Object.keys(clr).includes("hue")){this.hue = clr.hue;}
            if(Object.keys(clr).includes("sat")){this.sat = clr.sat;}
            if(Object.keys(clr).includes("lum")){this.lum = clr.lum;}
            if(Object.keys(clr).includes("alp")){this.alp = clr.alp;}
            // this.color = "hsla(0,0%,50%,.5)";
            this.colorFlat = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
            this.color = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
            // this.color = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
            this.zdp = .5;




            this.xc = s.x;
            this.yc = s.y;
            this.zc = s.z2;
            // this.x = Math.random() * canvas.width;
            // this.y = Math.random() * canvas.height;
            this.angle = Math.random() * 360;
            this.angleZ = Math.random() * 360;
            // this.rotSp = Math.random() + .5;
            // this.radius = Math.random() * 5;
            this.radius = 5;
            // this.sizeLim = 2;
            // this.hueStart = Math.random() * 20 - 10;
            // this.hueRange = 60;
            // this.hueRange = 360;
            // this.hue = Math.floor(Math.random() * 360);
            this.radius_limit = 200;

        }
        getSize(){
            /* this.zdp will vary from 0 to 1. close and far, respectively. */
            // let box_z = (s.w + s.h)/2;
            // this.zdp = 1 - this.z/box_z;
            this.zdp = 1 - this.z/s.z;
            let zadd = parseFloat((this.zdp * this.size_range).toFixed(2));
            this.size_z = this.size + (this.size_range/2) - zadd;
        }
        getColor(){
            // this.calcColor();
            // this.lum = (80 - (this.zdp * 60)).toFixed(0);
            this.lum = (60 - (this.zdp * 20)).toFixed(0);
            // this.hue = (360 - (this.zdp * 360)).toFixed(0);
            // this.ydp = 1 - this.y/s.h;
            this.hue = (this.y / s.h * 360).toFixed(0);
            
            this.color = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
            // return this.color;
        }
        update(){
            this.time -= this.entropy;
            // this.time--;
            if(this.time < 1){
                this.time = 0;
                this.angle = Math.random() * 360;
                this.angleZ = Math.random() * 360;
            }

            // if(s.view.x + s.view.y != 0){
            // if(s.rotating.xdegs + s.rotating.ydegs != 0){
            //     // this.rotating.x = s.view.x;
            //     // this.rotating.y = s.view.y;
            //     this.rotating.x = s.rotating.xdegs;
            //     this.rotating.y = s.rotating.ydegs;
            // }
            // if(this.rotating.x + this.rotating.y != 0){
            //     // let xyz = RotateXY(s.rotating.xdegs,s.rotating.ydegs);
            //     let xyz = this.RotateXY(this.rotating.x,this.rotating.y);
            //     if(!s.touch.tracking){
            //         this.s.x = xyz.x;
            //         this.s.y = xyz.y;
            //         this.s.z = xyz.z;
            //         this.rotating.x = 0;
            //         this.rotating.y = 0;
            //     }
            //     this.x = xyz.x;
            //     this.y = xyz.y;
            //     this.z = xyz.z;
            // }

            let timef = this.time / 100;
            let timefs = 1-(this.time / 100);
            this.radius = (timefs * 200) + 5;

            // let radius_percent = this.radius / this.radius_limit;

            // this.alp = Math.floor(((3*(1 - timefs)**2) * timefs)*100)/100;
            // this.alp = Math.floor(timef%100);
            this.alp = timef;
            
            this.hue += Math.floor(Math.random() * 6 - 3);
            // this.size = this.sizeLim * timefs + 1;
            
            // let gravity = (timefs * timefs) * (this.radius_limit / 3);
            let gravity = 1;

            // this.lum = 10 + (this.depth*50);

            // let cirZx = Math.cos(Math.PI*(this.angleZ/180));
            // let cirX = Math.cos(Math.PI*(this.angle/180)) * this.radius * cirZx;
            /*
            front view circle, cos → x, sin → y.
            top view circle, cos → xy, sin → z.
            */
            let aCos = Math.cos(Math.PI*(this.angle/180));
            let aSin = Math.sin(Math.PI*(this.angle/180));
            let zCos = Math.cos(Math.PI*(this.angleZ/180));
            let zSin = Math.sin(Math.PI*(this.angleZ/180));

            let sp_x = aCos * zCos * this.radius;
            let sp_y = aSin * zCos * this.radius;
            let sp_z = zSin * aSin * this.radius;

            this.x = sp_x + this.xc;
            this.y = sp_y + this.yc + gravity;
            this.z = sp_z + this.zc;

            // let cirX = Math.cos(Math.PI*(this.angle/180)) * this.radius;
            // let cirY = Math.sin(Math.PI*(this.angle/180)) * this.radius;
            // let cirZxy = Math.sin(Math.PI*(this.angleZ/180)) * this.radius;
            // let cirZ = Math.sin(Math.PI*(this.angleZ/180)) * this.radius;
            // this.x = cirX + this.xc;
            // this.y = cirY + this.yc + gravity;
            // this.z = cirZ + this.zc;

            this.getSize();
            this.getColor();
        }
        draw(ctx){
            if(this.x > 0 && this.x < (s.w) && this.y > 0 && this.y < (s.h)){
                ctx.fillStyle = this.colorFlat;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size/2, 0, Math.PI * 2);
                ctx.fill();
            } 
        }
        drawZ(ctx){
            if(this.x > 0 && this.x < (s.w) && this.y > 0 && this.y < (s.h)){
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size_z/2, 0, Math.PI * 2);
                ctx.fill();
            } 
        }

        RotateXY(rx=0,ry=0){
            let x = this.s.x - s.x2;
            let y = this.s.y - s.y2;
            let z = this.s.z - s.z2;
            // let x = x0 - s.x2;
            // let y = y0 - s.y2;
            // let z = z0 - s.z2;
            if(rx != 0){
                let hx = Math.sqrt(z*z+y*y);
                let angleX = XYtoCSSAngle(z,y);
                let zy = CSSAngleToXY(angleX + rx);
                z = zy.x*hx;
                y = zy.y*hx;
            }
            if(ry != 0){
                let hy = Math.sqrt(x*x+z*z);
                let angleY = XYtoCSSAngle(x,z);
                let xz = CSSAngleToXY(angleY + ry);
                x = xz.x*hy;
                z = xz.y*hy;
            }
            x += s.x2;
            y += s.y2;
            z += s.z2;

            let nxt = {"x":x,"y":y,"z":z};
            return nxt;
        }
    }

    class FireWorks4 {
        constructor(id, x, y, z, hue){
            this.id = id;
            this.nodeCount = count;
            this.depth = (this.id / this.nodeCount);

            this.xc = s.x;
            this.yc = s.y;
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.angle = Math.random() * 360;
            this.angleZ = Math.random() * 360;
            this.rotSp = Math.random() + .5;
            this.radius = Math.random() * 5;

            this.time = 100;
            this.entropy = .5;
            
            this.hue = hue;
            this.sat = 100;
            this.lum = 70;
            this.alp = 1;
            
            this.sizeLim = 2;
            this.hueStart = Math.random() * 20 - 10;
            // this.hueRange = 60;
            // this.hueRange = 360;
            // this.hue = Math.floor(Math.random() * 360);
            this.radius_limit = 200;

            this.size = Math.random() * 2 + .1;
            this.spX = Math.random() * 3 - 1.5;
            this.spY = Math.random() * 3 - 1.5;
        }
        update(){
            this.time -= this.entropy;
            if(this.time < 1){
                this.time = 0;
                this.angle = Math.random() * 360;
                this.angleZ = Math.random() * 360;
            }
            let timef = this.time / 100;
            let timefs = 1-(this.time / 100);
            this.radius = (timefs * 200) + 5;

            let radius_percent = this.radius / this.radius_limit;

            // this.alp = Math.floor(((3*(1 - timefs)**2) * timefs)*100)/100;
            // this.alp = Math.floor(timef%100);
            this.alp = timef;
            
            this.hue += Math.floor(Math.random() * 6 - 3);
            this.size = this.sizeLim * timefs + 1;
            
            let gravity = (timefs * timefs) * (this.radius_limit / 3);

            this.lum = 10 + (this.depth*50);

            let cirZx = Math.cos(Math.PI*(this.angleZ/180));
            let cirX = Math.cos(Math.PI*(this.angle/180)) * this.radius * cirZx;
            let cirY = Math.sin(Math.PI*(this.angle/180)) * this.radius;
            this.x = cirX + this.xc;
            this.y = cirY + this.yc + gravity;

        }
        draw(){
            ctx.fillStyle = `hsla(${this.hue}, ${this.sat}%, ${this.lum}%, ${this.alp})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function start(){
        // // for (let index = 0; index < 100; index++) {
        // //     particles.push(new Particle());
        // // }
        // let firehue = Math.floor(Math.random() * 360);
        // let nodeCount = 50;
        // for (let index = 0; index < nodeCount; index++) {
        //     // particles.push(new Spark());
        //     // particles.push(new FireWorks());
        //     // particles.push(new FireWorks2(index, nodeCount));
        //     // particles.push(new FireWorksMouse(index, nodeCount));
        //     particles.push(new FireWorks3(index, nodeCount, firehue));
        // }
    }
    function handleParticles(){
        /* mouse_particles */
        if(mouse_particles.length > 0){
            for (let index = 0; index < mouse_particles.length; index++) {
                const element = mouse_particles[index];
                element.update();
                element.draw();
                if(element.time == 0) {
                    mouse_particles.splice(index,1);
                    index--;
                }
            }
        }
        /* click_particles */
        if(click_particles.length > 0){
            for (let index = 0; index < click_particles.length; index++) {
                const element = click_particles[index];
                element.update();
                element.draw();
                if(element.time == 0) {
                    click_particles.splice(index,1);
                    index--;
                }
            }
        }
        

        if(particles.length > 0) {
            for (let index = 0; index < particles.length; index++) {
                const element = particles[index];
                element.update();
                element.draw();
                if(element.time == 0) {
                    particles.splice(index,1);
                    index--;
                }
            }
        }
    }

    function animate (){
        // ctx.fillStyle = `#0008`;
        ctx.fillStyle = `#0002`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        let particleCount = particles.length + click_particles.length + mouse_particles.length;
        if(particleCount > 0){
            // console.log(particleCount);
            handleParticles();
        }

        // ctx.clearRect(0,0,canvas.width, canvas.height);
        // hueHelix();
        // handleParticles();
        requestAnimationFrame(animate);
    }

    function update(){
        if(!s.q && !s.pause){
            /* ─ Calculate Part ─ */
            for(let i = 0; i < particles.length; i++){particles[i].update();}
            particles.sort((a,b) => a.z - b.z);

            /* ─ Draw Part ─ */
            // clearCanvas("#0001");
            for(let i = 0; i < particles.length; i++){
                const e = particles[i];
                // draw_e(ctx,particles[i]);
                // draw_z(ctx,particles[i]);
                e.drawZ(ctx);
            }
        }
        setTimeout(() => {
            requestAnimationFrame(update);
        }, s.timeOut)
    }
    function clearCanvas(clr="#000"){
        // ctx.clearRect(0,0,s.w,s.h);
        ctx.fillStyle = clr;
        ctx.fillRect(0,0,s.w,s.h);
    }

    var spellBook = {
        "boom": true,
        "particles": 100,
        "pause": false,
        "current": "none"
    }
    window.addEventListener('click', (ev) =>{
        let firehue = Math.floor(Math.random() * 360);
        if(spellBook.boom){
            for (let index = 0; index < spellBook.particles; index++) {
                // click_particles.push(new FireWorks2(index, spellBook.particles));
                // click_particles.push(new FireWorks3(index, spellBook.particles, firehue));

                // let firehue = Math.floor(Math.random() * 360);
                // click_particles.push(new FireWorks4(index, s.x2, s.y2, s.z2, firehue));
                particles.push(new pz2(index, "fireworks", s.x2, s.y2, s.z2, {"hue":firehue}));
            }
        }
    });

    /* ───── Mouse Move ───── */
    window.addEventListener('mousemove', (ev) =>{
        s.x = ev.clientX;
        s.y = ev.clientY;
        moveSpark();
    });
    function moveSpark() {
        let nodeCount = 50;
        if(mouse_particles.length < nodeCount) {
            for (let index = 0; index < nodeCount; index++) {
                mouse_particles.push(new FireWorksMouse(index, nodeCount));
            }
        }
    }


    /* ─── Events ─── */
    function updateSettings(){
        // s.y = window.innerHeight;
        // s.x = window.innerWidth;
        s.h = window.innerHeight;
        s.w = window.innerWidth;
        s.z = window.innerWidth;
        s.dim = Math.sqrt(s.h * s.h + s.w * s.w);

        /* ─ Center of Screen ─ */
        s.x2 = s.w/2;
        s.y2 = s.h/2;
        s.z2 = s.w/2;

        /* ─ Canvas ─ */
        s.canvas.x = s.w;
        s.canvas.y = s.h;
        s.canvas.z = (s.h + s.w)/2;

        s.canvas.x2 = s.canvas.x/2;
        s.canvas.y2 = s.canvas.y/2;
        s.canvas.z2 = s.canvas.z/2;

        /* ─ Box ─ */
        /* resize box for mobile */
        if(s.h < s.box.y) {s.box.y = s.h;}
        if(s.w < s.box.x) {s.box.x = s.w;}
        s.box.z = (s.box.y + s.box.x)/2;

        /* center box */
        s.box.top = (s.h - s.box.y)/2;
        s.box.left = (s.w - s.box.x)/2;

        /* determine center */
        s.box.x2 = s.box.left + (s.box.x / 2);
        s.box.y2 = s.box.top + (s.box.y / 2);
        s.box.z2 = (s.box.z / 2);

        /* ─ Grid ─ */
        s.grid.cols = Math.floor(s.w / s.tile.w);
        s.grid.rows = Math.floor(s.h / s.tile.h);

        /* ─ Canvas Update ─ */
        canvas.width = s.canvas.x;
        canvas.height = s.canvas.y;
        s.x = canvas.width/2;
        s.y = canvas.height/2;
        ctx.clearRect(0,0,canvas.width, canvas.height);
    }
    window.addEventListener('resize', () =>{
        updateSettings();
    });

    window.addEventListener('load', (ev) => {
        console.log(`Welcome to my Lab!`);
        updateSettings();
        s.x = canvas.width/2;
        s.y = canvas.height/2;
        start();
        // animate();
        update();
    });
</script>
</body>
</html>