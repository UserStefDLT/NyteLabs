<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="https://raw.githubusercontent.com/UserStefDLT/WebResources/master/Images/icon_st.png">
    <title>Cube Attempt | NyteLabs</title>
    <link rel="stylesheet" href="../../../stylesheets/start.css">
    <link rel="stylesheet" href="../../../stylesheets/labst.css">
    <!-- <link rel="stylesheet" href="../../../stylesheets/canvas.css"> -->
    <style>
        /* *::before, *::after {
            position: absolute;
            top: 50%; left: 50%;
            transform: translateX(-50%) translateY(-50%);
        } */
        /* :root {} */
        </style>
<style>
    :root {
        --sz-side: 60px;
        --sz: 120px;
        --sz: 100px;
        --sz-h: calc(var(--sz) / 2);
        --p: 50000px;
        --p: 5000px;
        --p: 1000px;
        --iso-deg: 54deg;
        --x-deg: 0deg;
        --y-deg: 0deg;
        --z-deg: 0deg;

        --hue-side: 0;
        --hue-step: 30;
        --alp: .75;
    }

    :root {
        --sz-tile: 20px;
        --szh-tile: 10px;
        --sz2-tile: 10px;
        --sz4-tile: 5px;
        --sz-2-tile: -10px;
        --hue-side: 60;
        --hue-step: 9;
        --alp: 1;

        --x-deg: -50deg;
        --y-deg: -45deg;
    }
    /* .class {} */
    .grid, .row, .column {
        transform-style: preserve-3d;
    }
    .grid {
        position: relative;
        display: flex;
        flex-direction: column;
        transform: rotate3d(1,0,0,54deg) rotate3d(0,0,1,45deg);
        margin: -8px 0px;

        transform: rotate3d(1, 0, 0, 90deg) rotate3d(0, 0, 0, 45deg);
        margin: 0px;
        height: 20px;
    }
    .column {
        display: flex;
        flex-direction: column;
    }
    .row {
        display: flex;
        font-display: row;
    }
    [data-val] {
        position: relative;
        transform-style: preserve-3d;
        height: 20px;
        width: 20px;
        height: var(--sz-tile);
        width: var(--sz-tile);
        display: flex;
        align-items: center; justify-content: center;
        color: #0000;
    }
    [data-val="1"] {
        /* background-color: #0f0; */
        color: #000;
    }

    .column {
        transform: translateZ(10px) translateY(20px);
    }
    /* .column {
        transform: rotate3d(-1, -.5, 0, 45deg);
    } */
    /* [data-val="1"] {
        position: relative;
        transform-style: preserve-3d;
    } */
    [data-val="0"] {
        opacity: 1;
        --alp: 1;
    }
    [data-val="-1"] {
        opacity: 0;
    }

    /* [data-val="1"]::before,
    [data-val="1"]::after {
        content: "";
        position: absolute;
        top: 0; left: 0;
        height: 100%;
        width: 100%;
        transform-style: preserve-3d;
        transform-origin: 100% 100%;
        transform: translate(-50%,-50%) rotate3d(1,0,0,90deg);
        transform: rotate3d(1,0,0,90deg);
        
        background-color: #f008;
        background-color: #0c0;
        background-image: linear-gradient(#0a0, #0c0);
        color: #000;
    }
    [data-val="1"]::after {
        transform: translate(-50%,-50%) rotate3d(0,1,0,-90deg);
        transform: rotate3d(0,1,0,-90deg);
        
        background-color: #00f8;
        background-color: #0c0;
        background-image: linear-gradient(90deg, #0a0, #0c0);

        color: #000;
    } */

    .zf, .zb, .yu, .yd, .xr, .xl {
        --hue-side: var(--i);
        position: absolute;
        top: 0; left: 0;
        /* top: calc((100% - var(--sz)) / 2); left: calc((100% - var(--sz)) / 2); */
        top: calc((100% - var(--sz-tile)) / 2); left: calc((100% - var(--sz-tile)) / 2);
        height: max-content;
        width: max-content;
        height: 120px; width: 120px;
        height: var(--sz); width: var(--sz);
        height: var(--sz-tile); width: var(--sz-tile);
        display: flex;
        align-items: center;
        justify-content: center;
        
        transform-style: preserve-3d;
        transform-origin: 60px 60px -60px;
        transform-origin: var(--sz-h) var(--sz-h) var(--sz-h);
        transform-origin: var(--sz-h) var(--sz-h) calc(var(--sz-h) * -1);
        transform-origin: var(--sz2-tile) var(--sz2-tile) calc(var(--sz2-tile) * -1);
        transform-origin: var(--sz2-tile) var(--sz2-tile) calc(var(--sz4-tile) * -1);

        /* background-color: hsla(calc(var(--hue-side) * var(--hue-side)), 100%, 50%, var(--alp)); */
        /* background-color: hsla(calc(var(--step) * var(--hue-step)), 100%, 50%, var(--alp)); */
        background-image: radial-gradient(#0000 50%, #0003 100%);
        --bgc: hsla(calc(var(--step) * var(--hue-step)), 100%, 50%, var(--alp));
        background-image: 
        radial-gradient(#0000 50%, #0003 100%),
        linear-gradient(0deg, var(--bwt) 25%, var(--bgc) 25%, var(--bgc) 75%, var(--bwt) 75%),
        linear-gradient(90deg, var(--bwt) 25%, var(--bgc) 25%, var(--bgc) 75%, var(--bwt) 75%),
        radial-gradient(#0000 50%, #0003 100%);
        background-image: 
        linear-gradient(0deg, var(--bwt) 25%, var(--bgc) 25%, var(--bgc) 75%, var(--bwt) 75%),
        linear-gradient(90deg, var(--bwt) 25%, var(--bgc) 25%, var(--bgc) 75%, var(--bwt) 75%);

        backface-visibility: hidden;
        transition: transform 300ms ease-in-out;
    }

    /* .xr {transform: translateZ(var(--sz-tile)) rotate3d(1,0,0,-90deg);}
    .xl {transform: translateZ(var(--sz-tile)) rotate3d(1,0,0,90deg);}

    .yu {transform: translateZ(var(--sz-tile));}
    .yd {transform: translateZ(var(--sz-tile)) rotate3d(1,0,0,180deg);}

    .zf {transform: translateZ(var(--sz-tile)) rotate3d(0,1,0,90deg);}
    .zb {transform: translateZ(var(--sz-tile)) rotate3d(0,1,0,-90deg);} */


    .xr {transform: translateZ(var(--szh-tile)) rotate3d(1,0,0,-90deg);}
    .xl {transform: translateZ(var(--szh-tile)) rotate3d(1,0,0,90deg);}
    .yu {transform: translateZ(var(--szh-tile));}
    .yd {transform: translateZ(var(--szh-tile)) rotate3d(1,0,0,180deg);}
    .zf {transform: translateZ(var(--szh-tile)) rotate3d(0,1,0,90deg);}
    .zb {transform: translateZ(var(--szh-tile)) rotate3d(0,1,0,-90deg);}

    [data-val="1"] .zf, 
    [data-val="1"] .zb, 
    [data-val="1"] .yu, 
    [data-val="1"] .yd, 
    [data-val="1"] .xr, 
    [data-val="1"] .xl {
        background-image: 
        linear-gradient(#fff 10%, #0000 10%, #0000 90%, #fff 90%), 
        linear-gradient(90deg, #fff 10%, #0000 10%, #0000 90%, #fff 90%), 
        radial-gradient(#0000 50%, #0003 100%);
    }
    [data-val="9"] .zf, 
    [data-val="9"] .zb, 
    [data-val="9"] .yu, 
    [data-val="9"] .yd, 
    [data-val="9"] .xr, 
    [data-val="9"] .xl {
        background-image: 
        linear-gradient(#000 10%, #0000 10%, #0000 90%, #000 90%), 
        linear-gradient(90deg, #000 10%, #0000 10%, #0000 90%, #000 90%), 
        radial-gradient(#0000 50%, #0003 100%);
    }

    /* Visualizing coordinates. */
    /* [data-zyx] {
        position: relative;
        transform-style: preserve-3d;
    }
    [data-zyx]::before {
        content: attr(data-zyx);
        position: absolute;
        top: 0; left: 0;
        height: max-content;
        width: max-content;
        color: #f39;
        background-color: #000;
        outline: #f398;
        opacity: 0;
        transform-style: preserve-3d;
        transform: rotateX(90deg) translateZ(4px);
        transition: 
        opacity 300ms ease-in-out,
        transform 300ms ease-in-out;
    }
    [data-zyx]:hover::before {
        opacity: 1;
        transform: rotateX(0deg) translateZ(4px);
    } */
    /*  */

    .box-02 {
        position: relative;
        height: 150px; width: 150px;
        /* height: auto; width: auto; */
        margin: 5rem;

        display: flex;
        align-items: center;
        justify-content: center;
        
        outline: 1px dashed #fff9;
        outline-offset: 2px;
        border-radius: 50%;

        transform-style: preserve-3d;
        /* transform: perspective(var(--p)) rotate3d(1,0,0,54deg) rotate3d(0,0,1,45deg); */
        /* transform: perspective(var(--p)) rotate3d(1,0,0,var(--x-deg)) rotate3d(0,1,0,var(--y-deg)) rotate3d(0,0,1,var(--z-deg)); */
        /* transform: perspective(var(--p)) rotate3d(1,0,0,var(--x-deg)) rotate3d(0,1,0,var(--y-deg)); */
        transform: perspective(var(--p)) rotate3d(0,1,0,var(--x-deg)) rotate3d(-1,0,0,var(--y-deg));
        transition: transform 0ms linear;

        cursor: grab;
        user-select: none;
    }
</style>
    <link rel="stylesheet" href="../../../stylesheets/settings2.css">
    <link rel="stylesheet" href="../../../stylesheets/end.css">
</head>
<body>
    <header>
        <a href="../../../index.html" class="backLink hidden"><div class="backBtn">Back?</div></a>
        <h1 class="title">NyteLabs</h1>
        <!-- <div class="subtitle">NyteLabs_Template</div> -->
    </header>
    <input type="checkbox" name="toggle" id="toggleAnimation">
    <input type="checkbox" name="toggle" id="toggleOpacity">
    <input type="checkbox" name="toggle" id="toggleLights">

<main>
    <div class="shelf">
        <h3 class="shelf-title">experiment</h3>
        <div id="display" class="box-02"></div>
    </div>
    <!-- <canvas id="canvas"></canvas> -->
     <!-- <div class="zf"></div>
     <div class="zb"></div>
     <div class="yu"></div>
     <div class="yd"></div>
     <div class="xr"></div>
     <div class="xl"></div> -->
</main>

<!-- <div class="options">
    <label for="toggleAnimation" class="toggleCheckboxLabel" data-toggle="Animation">Animation</label>
    <label for="toggleLights" class="toggleCheckboxLabel" data-toggle="Lights">ğŸ’¡</label>
    <label for="toggleOpacity" class="toggleCheckboxLabel" data-toggle="Opacity">Opacity</label>
</div> -->

<footer>
    <div class="my-name">
        <a id="BackToTop" class="hidden" href="#">Back To Top</a>
        &copy; 2022 - 2026 | by StÃ©fano De La Torre 
    </div>
</footer>
<div class="name-end">by St&eacute;fano.</div>
<!-- <script src="main.js"></script> -->
<script>
    /* Constant Variables */
    const s = {
        h: window.innerHeight,
        w: window.innerWidth,

        touch: {
            x: 0,
            y: 0,
            z: 0,
            paths: {},
            path_len: 20,
            tracking: false
        },
        mouse: {
            x: 0,
            y: 0,
            z: 0,
            path: [],
            path_len: 20,
            tracking: false
        },
        tile: {
            h: 20,
            w: 20,
            sz: 20,
            sz2: 10,
            margin: 16,
            fill: 0
        },
        grid: {
            h: window.innerHeight,
            w: window.innerWidth,
            cols: 15,
            rows: 15,
            margin: 24
        },
        canvas: {
            h: window.innerHeight,
            w: window.innerWidth,
            padding: 0,
            brush: "p",
        },
        box: {
            x: 500,
            y: 500,
            z: 500,
            x2: 250,
            y2: 250,
            z2: 250,
            d: 1000,
            p: 1000,
        },
        cube: {
            xlen: 5,
            ylen: 5,
            zlen: 5
        },

        timeOut: 40,
        player: false,
        
        s: false,
        steps: false,
        tags: false,
        log: false,
        lockKeys: false,
        pause: false,
        q: false
    }
    const particles = [];
    const pg = {}
    const box = {
        x: -50,
        y: -45,
        z: 0,
        start: {
            x: 0,
            y: 0,
            z: 0,
        },
        touches: [],
        touch_xyz: {'x': 0, 'y': 0, 'z': 0},

        grabing: false
    };

    const sides = [5, 12, 14, 16, 18, 25];
    const sides_around = [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 16, 17, 18, 19, 21, 22, 23, 24, 25, 26, 27, 28, 29];
const xyzSide = {
        0:{z:-1,y:0,x:0},
        1:{z:-1,y:1,x:-1},
        2:{z:-1,y:1,x:0},
        3:{z:-1,y:1,x:1},
        4:{z:-1,y:0,x:-1},
        5:{z:-1,y:0,x:0},
        6:{z:-1,y:0,x:1},
        7:{z:-1,y:-1,x:-1},
        8:{z:-1,y:-1,x:0},
        9:{z:-1,y:-1,x:1},
        10:{z:0,y:0,x:0},
        11:{z:0,y:1,x:-1},
        12:{z:0,y:1,x:0},
        13:{z:0,y:1,x:1},
        14:{z:0,y:0,x:-1},
        15:{z:0,y:0,x:0},
        16:{z:0,y:0,x:1},
        17:{z:0,y:-1,x:-1},
        18:{z:0,y:-1,x:0},
        19:{z:0,y:-1,x:1},
        20:{z:1,y:0,x:0},
        21:{z:1,y:1,x:-1},
        22:{z:1,y:1,x:0},
        23:{z:1,y:1,x:1},
        24:{z:1,y:0,x:-1},
        25:{z:1,y:0,x:0},
        26:{z:1,y:0,x:1},
        27:{z:1,y:-1,x:-1},
        28:{z:1,y:-1,x:0},
        29:{z:1,y:-1,x:1}
    };

</script>
<script src="../../../scripts/settings-02.js"></script>
<script>

var level = [];
const maze_settings = {
    wall: -1,
    path: 0,
    start: 1,
    end: 9
}
var vmap = [];
var cmap = [];

function Build3dMapDisplaySteps(maze,steps,xlen,ylen,zlen){
    /* for xyz. */
    let cube = [];
    for(let z = 0; z < zlen; z++){
        cube.push([]);
        for(let y = 0; y < ylen; y++){
            cube[z].push([]);
            for(let x = 0; x < xlen; x++){
                var val = maze[z][y][x];
                var step = steps[z][y][x];
                let zyx = `${z},${y},${x}`;
                if(val == -1){
                    cube[z][y].push(`<div data-val="${val}" data-zyx="${zyx}"></div>`);
                } else {
                    cube[z][y].push(`<div data-val="${val}" data-zyx="${zyx}" style="--step: ${step};">
                        <div class="zf"></div>
                        <div class="zb"></div>
                        <div class="yu"></div>
                        <div class="yd"></div>
                        <div class="xr"></div>
                        <div class="xl"></div>
                    </div>`);
                }
            }
        }
    }
    return cube;
}
function Build3dMapDisplay(maze,xlen,ylen,zlen){
    /* for xyz. */
    let cube = [];
    for(let z = 0; z < zlen; z++){
        cube.push([]);
        for(let y = 0; y < ylen; y++){
            cube[z].push([]);
            for(let x = 0; x < xlen; x++){
                var val = maze[z][y][x];
                let zyx = `${z},${y},${x}`;
                if(val == -1){
                    cube[z][y].push(`<div data-val="${val}" data-zyx="${zyx}"></div>`);
                } else {
                    cube[z][y].push(`<div data-val="${val}" data-zyx="${zyx}">
                        <div class="zf"></div>
                        <div class="zb"></div>
                        <div class="yu"></div>
                        <div class="yd"></div>
                        <div class="xr"></div>
                        <div class="xl"></div>
                    </div>`);
                }
            }
        }
    }
    return cube;
}
function Exp_BuildRand3dMap_1(xlen = 1,ylen = 1,zlen = 1){
    /* for xyz, or whd. */
    cube = [];
    for(let z = 0; z < zlen; z++){
        cube.push([]);
        for(let y = 0; y < ylen; y++){
            cube[z].push([]);
            for(let x = 0; x < xlen; x++){
                var val = Math.floor(Math.random()*2);
                let zyx = `${z},${y},${x}`;
                cube[z][y].push(`<div data-val="${val}" data-zyx="${zyx}">
                    <div class="zf"></div>
                    <div class="zb"></div>
                    <div class="yu"></div>
                    <div class="yd"></div>
                    <div class="xr"></div>
                    <div class="xl"></div>
                </div>`);
            }
        }
    }
    return cube;
}
function Exp_BuildRand3dMap_0(xlen = 1,ylen = 1,zlen = 1){
    /* for xyz, or whd. */
    cube = [];
    for(let z = 0; z < zlen; z++){
        cube.push([]);
        for(let y = 0; y < ylen; y++){
            cube[z].push([]);
            for(let x = 0; x < xlen; x++){
                var val = Math.floor(Math.random()*2);
                let zyx = `${z},${y},${x}`;
                cube[z][y].push(`<div data-val="${val}" data-zyx="${zyx}">${val}</div>`);
            }
        }
    }
    return cube;
}
function BuildRand3dMap(xlen = 1,ylen = 1,zlen = 1){
    /* for xyz, or whd. */
    cube = [];
    for(let z = 0; z < zlen; z++){
        cube.push([]);
        for(let y = 0; y < ylen; y++){
            cube[z].push([]);
            for(let x = 0; x < xlen; x++){
                cube[z][y].push(Math.floor(Math.random()*2));
            }
        }
    }
    return cube;
}
function Build3dMapF(xlen = 1,ylen = 1,zlen = 1, fill = 0){
    /* for xyz, or whd. */
    cube = [];
    for(let z = 0; z < zlen; z++){
        cube.push([]);
        for(let y = 0; y < ylen; y++){
            cube[z].push([]);
            for(let x = 0; x < xlen; x++){
                cube[z][y].push(fill);
            }
        }
    }
    return cube;
}
function Build3dMap(xlen = 1,ylen = 1,zlen = 1){
    /* for xyz, or whd. */
    cube = [];
    for(let z = 0; z < zlen; z++){
        cube.push([]);
        for(let y = 0; y < ylen; y++){
            cube[z].push([]);
            for(let x = 0; x < xlen; x++){
                cube[z][y].push(-1);
            }
        }
    }
    return cube;
}
function BuildMap(xlen,ylen){
    g = [];
    for(let y = 0; y < ylen; y++){
        g.push([]);
        for(let x = 0; x < xlen; x++){
            g[y].push(0);
        }
    }
    return g
}

/* Classes */
class Maze3 {
    constructor(xlen, ylen, zlen, fill = -1) {
        // this.h = h;
        // this.w = w;
        this.xlen = xlen;
        this.ylen = ylen;
        this.zlen = zlen;

        this.fill = fill;
        this.start = {x: 0, y: 0, z: 0};
        this.end = {x: 0, y: 0, z: 0, d: 0};
        this.maze = [];
        this.stepMap = [];
        this.step = 0;

        this.Build3dMap();
        // this.FillMap();
        this.SelectStart();
    }
    // FillMap(fill = this.fill) {
    //     this.maze = [];
    //     this.stepMap = [];
    //     for (let y = 0; y < this.h; y++) {
    //         this.maze.push([]);
    //         this.stepMap.push([]);
    //         for (let x = 0; x < this.w; x++) {
    //             this.maze[y].push(fill);
    //             this.stepMap[y].push(0);
    //         }
    //     }
    // }
    Build3dMap(){
        /* for xyz, or whd. */
        // cube = [];
        this.maze = [];
        this.stepMap = [];
        for(let z = 0; z < this.zlen; z++){
            // cube.push([]);
            this.maze.push([]);
            this.stepMap.push([]);
            for(let y = 0; y < this.ylen; y++){
                // cube[z].push([]);
                this.maze[z].push([]);
                this.stepMap[z].push([]);
                for(let x = 0; x < this.xlen; x++){
                    // cube[z][y].push(0);
                    this.maze[z][y].push(this.fill);
                    this.stepMap[z][y].push(this.fill);
                }
            }
        }
        // return cube;
    }
    SelectStart() {
        // this.start.x = Math.floor(Math.random() * this.xlen);
        // this.start.y = Math.floor(Math.random() * this.ylen);
        // this.start.z = Math.floor(Math.random() * this.zlen);
        // this.MoveTo(this.start.x, this.start.y, this.start.z, 1);
        
        this.start.x = 0;
        this.start.y = 0;
        this.start.z = this.zlen-1;
        this.MoveTo(this.start.x, this.start.y, this.start.z, 1);
    }
    SelectEnd() {
        // this.MoveTo(this.end.x, this.end.y, 9);
        // this.MoveTo(this.end.x, this.end.y, 9, this.end.d);
        this.maze[this.end.z][this.end.y][this.end.x] = 9;
        // this.UpdateTileInDOM(this.end.x, this.end.y, 9, this.end.d);
    }

    IsInMap(x,y,z){
        if(x < 0 || y < 0 || z < 0 || x >= this.xlen || y >= this.ylen || z >= this.zlen) {
            return false;
        }
        return true;
    }
    IsTile(x,y,z,tile){
        if(this.IsInMap(x,y,z)){
            return this.maze[z][y][x] == tile;
        } 
        // else {return false;}
    }
    IsClear(x,y,z) {
        // basically, if it is a wall;
        return this.IsTile(x, y, z, -1);
        // return this.IsTile(x, y, z, this.fill);
    }

    /* 
        from a specific position, it will check its side adjecent tiles if they are clear, meaning, not a path. 
        unless it is the starting position, there will always be at least one that is a path.

        it will return the valid sides as 2,4,6,8 as the directions that are clear.
    */
    ValidSides(x,y,z) {
        let valid = [];
        for (let i = 0; i < sides.length; i++) {
            let d = sides[i];
            let nx = x + xyzSide[d].x;
            let ny = y + xyzSide[d].y;
            let nz = z + xyzSide[d].z;
            if (this.IsClear(nx, ny, nz)) {
                valid.push(d);
            }
        }
        console.log(`Valid Sides at ${this.step}:`);
        console.log(valid);
        return valid;
    }
    /* 
        CheckAround will check all tiles around the given position.
        x and y will be the position we are coming from, so, we will ignore that one.
        nx and ny are the direction we are going, so, well check around that one.
        ax and ay are the adjecent to the tile we are moving to.


    */
    CheckAround(x,y,z,nx,ny,nz,d) {
        for (let i = 0; i < sides_around.length; i++) {
            let ad = sides_around[i];
            let ax = nx + xyzSide[ad].x;
            let ay = ny + xyzSide[ad].y;
            let az = nz + xyzSide[ad].z;

            
            // if outside of map, ignore.
            // if same as previous, ignore.
            // Avoid all the back from previous.
            // if all wall, return true.
            // if any path, return false.

            let dx = xyzSide[d].x * -1;
            let dy = xyzSide[d].y * -1;
            let dz = xyzSide[d].z * -1;
            let adx = xyzSide[ad].x;
            let ady = xyzSide[ad].y;
            let adz = xyzSide[ad].z;
            
            if(this.IsInMap(ax,ay,az)){
                if(!((dx && dx == adx) || (dy && dy == ady) || (dz && dz == adz)) && !this.IsTile(ax,ay,az,-1)){
                    console.log(`x: ${x}, y: ${y}, z: ${z}; d: ${d} \nnx: ${nx}, ny: ${ny}, nz: ${nz}; \nax: ${ax}, ay: ${ay}, az: ${az};`);
                    return false;
                }
            }

            /*
            If previous, ignore.
            If not previous, 
                if adjecent path, then false.
                if adjecent out of map, ignore.
                if adjecent only walls, then true.
            */

            /* 
                if the direction we are going is the same where we came from, then ignore.
                (xyzSide[d].x && x == ax) 
                    the first part with the && makes it ignore this axis if it is 0 on the direction.
                    the second part compares the direction of origin 'x' with the adjectent direction 'ax'
                    then if it is a '0' on 'x' (which happens on direction 8 and 2, then ignore the comparison)
                    if the direction on 'x' is '1' or '-1', then let's check if it is the same as the adjecent we are checking.
                    if x and y are the same, then we know it is the direction we came from, so, ignore this direction.
                    [I think I can do this better, but I won't fix it if it works]

                if the adjecent we are asking about is not the previous one, then we check if it is clear.
                    !this.IsClear(ax, ay)
                    if it is by some chance not clear, then it is a path, then we return false, so they don't move here.
            */

            // if(!((xyzSide[d].x && x == ax) || (xyzSide[d].y && y == ay) || (xyzSide[d].z && z == az)) && !this.IsTile(ax,ay,az,-1)){
            //     console.log(`x: ${x}, y: ${y}, z: ${z}; nx: ${nx}, ny: ${ny}, nz: ${nz}; ax: ${ax}, ay: ${ay}, az: ${az}; d: ${d}`);
            //     return false;
            // }

            // if(this.IsInMap(ax,ay,az)){
            //     if(!((xyzSide[d].x && x == ax) || (xyzSide[d].y && y == ay) || (xyzSide[d].z && z == az)) && !this.IsClear(ax,ay,az)){
            //         console.log(`x: ${x}, y: ${y}, z: ${z}; \nnx: ${nx}, ny: ${ny}, nz: ${nz}; \nax: ${ax}, ay: ${ay}, az: ${az}; d: ${d}`);
            //         return false;
            //     }
            // }

            // if(!((x == ax) && (y == ay) && (z == az)) && !this.IsClear(ax,ay,az)){
            //     console.log(`x: ${x}, y: ${y}, z: ${z}; nx: ${nx}, ny: ${ny}, nz: ${nz}; ax: ${ax}, ay: ${ay}, az: ${az}; d: ${d}`);
            //     return false;
            // }


        }
        return true;
    }

    MakePath_Helper(x,y,z, steps = this.step) {
        let validSides = this.ValidSides(x,y,z);
        if(validSides.length > 0) {
            let sidesLeft = [...validSides];
            
            for (let i = 0; i < validSides.length; i++) {
                /* This is what chooses a random valid side. */
                let d = sidesLeft.splice(Math.floor(Math.random() * sidesLeft.length), 1);

                let nx = x + xyzSide[d].x;
                let ny = y + xyzSide[d].y;
                let nz = z + xyzSide[d].z;

                let check = this.CheckAround(x,y,z,nx,ny,nz,d);
                console.log(`check(${d},${x},${y},${z}) >> ${check}`);
                if (check) {
                    this.MoveTo(nx,ny,nz, 0, steps);
                    this.MakePath_Helper(nx,ny,nz, steps + 1);
                }
                // if (this.CheckAround(x,y,z,nx,ny,nz,d)) {
                //     this.MoveTo(nx,ny,nz, 0, steps);
                //     this.MakePath_Helper(nx,ny,nz, steps + 1);
                // }
            }
        }
    }
    MakePath() {
        let x = this.start.x;
        let y = this.start.y;
        let z = this.start.z;
        // console.log(`start: ${x},${y},${z}`);

        let validSides = this.ValidSides(x,y,z);
        console.log(validSides);

        let d = validSides[Math.floor(Math.random() * validSides.length)];
        // console.log(d);

        let nx = x + xyzSide[d].x;
        let ny = y + xyzSide[d].y;
        let nz = z + xyzSide[d].z;

        this.MoveTo(nx,ny,nz);

        this.MakePath_Helper(nx,ny,nz);
        this.SelectEnd();
    }

    MoveTo(x,y,z, tile = 0, step = this.step) {
        // safeLog([`%c â†’ At step #%c${this.step}%c, MoveTo(%c${x}%c, %c${y}%c, %c${tile}%c, %c${step}%c)`, logSty.c, logSty.s, logSty.c, logSty.b, logSty.c, logSty.b, logSty.c, logSty.b, logSty.c, logSty.b, logSty.c]);
        this.maze[z][y][x] = tile;
        this.stepMap[z][y][x] = step;
        if (step >= this.end.d) {
            this.end.x = x;
            this.end.y = y;
            this.end.z = z;
            this.end.d = step;
        }
        this.step++;
        // this.UpdateTileInDOM(x,y,z, tile, step);
    }

    UpdateTileInDOM(x,y,z, tile = -1, step = 0) {
        let tile_id = `xy,${x},${y}`;
        let tile_elem = document.getElementById(tile_id);
        if (tile_elem) {
            // tile_elem.dataset.tile = tile;
            // tile_elem.dataset.step = step;
            // tile_elem.style = `--step: ${step};`;
            tile_elem.dataset.type = tile;
            // tile_elem.dataset.steps = step;
            // tile_elem.style = `--steps: ${step};`;
        }
    }
}



/* To select where the start will be. */
function MapStart(xlen,ylen,zlen){
    // for now, it return the start of 0,0,0;
    // next it should be 0 or the length-1 for one of the coordinates, and the other to random.
    return [0,0,0];
}
/* Next step: Paths */
function IsInMap(m,x,y,z){
    let inMap = true;
    if(x < 0 || y < 0 || z < 0) {inMap = false;}
    if(x >= m[0][0].length || y >= m[0].length || z >= m.length) {inMap = false;}
    return inMap;
}
function IsTile(m,x,y,z,t){
    console.log(`x: ${x}, y: ${y}, z: ${z}`);
    if(IsInMap(m,x,y,z)){
        return m[z][y][x] == t;
    } else {return false;}
}
function IsClear(m, x, y, z) {
    return this.IsTile(m, x, y, z, -1);
}
function RandomSide(){
    /*not ready*/
    /* I think we can have a random for either x,y,z; 
    and another for positive or negative. */
    let xyz = Math.floor(Maht.random()*3);
    let posneg = Math.floor(Maht.random()*2);
    
    
    return 0;
}



function ReviewMap(m){
    let zlen = m.length;
    let ylen = m[0].length;
    let xlen = m[0][0].length;
    let map = Build3dMapF(xlen,ylen,zlen,0);
    for (let z = 0; z < m.length; z++) {
        for (let y = 0; y < m[z].length; y++) {
            for (let x = 0; x < m[z][y].length; x++) {
                map[z][y][x] = {"5": 0, "12": 0, "14": 0, "16": 0, "18": 0, "25": 0};
                for (let i = 0; i < sides.length; i++) {
                    let d = sides[i];
                    let nx = x + xyzSide[d].x;
                    let ny = y + xyzSide[d].y;
                    let nz = z + xyzSide[d].z;
                    if(x == 0 && y == 0 && z == 0){
                        console.log(`d: ${d}, nx: ${nx}, ny: ${ny}, nz: ${nz}`);
                        console.log(`IsInMap(m,nx,ny,nz) -> ${IsInMap(m,nx,ny,nz)}`);
                    }
                    // if (IsInMap(m,nx,ny,nz)) {
                    //     map[z][y][x][d] = 1;
                    // }
                    // if (IsTile(m,nx,ny,nz,0) || IsTile(m,nx,ny,nz,1) || IsTile(m,nx,ny,nz,9)) {
                    //     map[z][y][x][d] = 1;
                    // }
                    if (!IsTile(m,nx,ny,nz,-1)) {
                        map[z][y][x][d] = 1;
                    }
                }
            }
        }
    }
    return map;
}
function ReviewMap1(m,xlen,ylen,zlen){
    let map = Build3dMapF(xlen,ylen,zlen,{"5": 0, "12": 0, "14": 0, "16": 0, "18": 0, "25": 0});
    for (let z = 0; z < m.length; z++) {
        for (let y = 0; y < m[z].length; y++) {
            for (let x = 0; x < m[z][y].length; x++) {
                for (let i = 0; i < sides.length; i++) {
                    let d = sides[i];
                    let nx = x + xyzSide[d].x;
                    let ny = y + xyzSide[d].y;
                    let nz = z + xyzSide[d].z;
                    if (IsInMap(m,x,y,z) && !IsTile(m,x,y,z,-1)) {
                        map[z][y][x][d] = 1;
                    }
                }
            }
        }
    }
    return map;
}


function LogOut(g){
    let cube_log = [`<div class="grid">`];
    for (let z = 0; z < g.length; z++) {
        for (let y = 0; y < g[z].length; y++) {
            const row = g[z][y];
            let rowEl = `<div class="row">${row.join("")}</div>`;
            // cube_log.push(row.join());
            cube_log.push(rowEl);
            // for (let x = 0; x < g[z][y].length; x++) {
            //     const e = g[z][y][x];
            // }
        }
        cube_log.push(`</div><div class="grid">`);
    }
    cube_log.push("</div>");
    // console.log(cube_log.join('\n'));
    return cube_log;
}
function LogOut2(g){
    let cube_log = [`<div class="row">â”€â”€â”€â”€</div>`,`<div class="grid">`];
    for (let z = 0; z < g.length; z++) {
        for (let y = 0; y < g[z].length; y++) {
            const row = g[z][y];
            let rowEl = `<div class="row">${row.join("")}</div>`;
            // cube_log.push(row.join());
            cube_log.push(rowEl);
            // for (let x = 0; x < g[z][y].length; x++) {
            //     const e = g[z][y][x];
            // }
        }
        cube_log.push(`</div><div class="row">â”€â”€â”€â”€</div><div class="grid">`);
    }
    cube_log.push("</div>");
    console.log(cube_log.join('\n'));
    return cube_log;
}
function LogOut1(g){
    let cube_log = ["â”€â”€â”€â”€"];
    for (let z = 0; z < g.length; z++) {
        for (let y = 0; y < g[z].length; y++) {
            const row = g[z][y];
            let rowEl = `<div class="row">${row.join("")}</div>`;
            // cube_log.push(row.join());
            cube_log.push(rowEl);
            // for (let x = 0; x < g[z][y].length; x++) {
            //     const e = g[z][y][x];
            // }
        }
        cube_log.push("â”€â”€â”€");
    }
    console.log(cube_log.join('\n'));
    return cube_log;
}

function DisplayCube(log){
    let display = document.getElementById("display");
    // display.innerHTML = `<div><p>${log.join("</p><p>")}</p></div>`;
    // display.innerHTML = `<div class="column"><div>${log.join("</div><div>")}</div></div>`;
    display.innerHTML = `<div class="column">${log.join("")}</div>`;
}
function DisplayCube1(log){
    let display = document.getElementById("display");
    // display.innerHTML = `<div><p>${log.join("</p><p>")}</p></div>`;
    display.innerHTML = `<div class="column"><div>${log.join("</div><div>")}</div></div>`;
    // display.innerHTML = `<div class="column">${log.join("")}</div>`;
}


/* â”€â”€â”€ Events â”€â”€â”€ */
function updateSettings(){
    s.h = window.innerHeight;
    s.w = window.innerWidth;
    s.dim = Math.sqrt(s.h * s.h + s.w * s.w);

    /* â”€ Canvas â”€ */
    s.canvas.x = s.w;
    s.canvas.y = s.h;
    s.canvas.z = (s.h + s.w)/2;

    s.canvas.x2 = s.canvas.x/2;
    s.canvas.y2 = s.canvas.y/2;
    s.canvas.z2 = s.canvas.z/2;

    /* â”€ Box â”€ */
    /* resize box for mobile */
    if(s.h < s.box.y) {s.box.y = s.h;}
    if(s.w < s.box.x) {s.box.x = s.w;}
    s.box.z = (s.box.y + s.box.x)/2;

    /* center box */
    s.box.top = (s.h - s.box.y)/2;
    s.box.left = (s.w - s.box.x)/2;

    /* determine center */
    s.box.x2 = s.box.left + (s.box.x / 2);
    s.box.y2 = s.box.top + (s.box.y / 2);
    s.box.z2 = (s.box.z / 2);

    /* â”€ Grid â”€ */
    s.grid.cols = Math.floor(s.w / s.tile.w);
    s.grid.rows = Math.floor(s.h / s.tile.h);

    /* â”€ Canvas Update â”€ */
    // canvas.width = s.canvas.x;
    // canvas.height = s.canvas.y;
    // ctx.clearRect(0,0,canvas.width, canvas.height);
}
window.addEventListener('resize', () =>{
    updateSettings();
});

const box2 = document.getElementById("display");
function startup() {
    box2.addEventListener("touchstart", handleBoxStart, false);
    box2.addEventListener("touchend", handleBoxEnd, false);
    box2.addEventListener("touchcancel", handleBoxCancel, false);
    box2.addEventListener("touchmove", handleBoxMove, false);
}
var ongoingTouches = [];
function handleBoxStart(evt) {
    evt.preventDefault();
    if(s.log){console.log(`%ctouchstart%c â†’ handleBoxStart()`, 'color: #3f9; background-color: #3f92; border-radius: 4px; padding: 2px;', 'color: #999;');}
    box.grabing = true;

    var touches = evt.changedTouches;
    for (var i = 0; i < touches.length; i++) {
        ongoingTouches.push(copyTouch(touches[i]));
        box.touches.push({'x': 0, 'y': 0, 'z': 0});
        box.touches[i].x += touches[i].pageX;
        box.touches[i].y += touches[i].pageY;
        // console.log(`%ci: %c${i}%c â†’ x: %c${touches[i].pageX}%c, y: %c${touches[i].pageY}`, 'color: #ccc', 'color: #39f', 'color: #ccc', 'color: #39f', 'color: #ccc', 'color: #39f');
        // console.log(`%c box â†’ x: %c${box.touches[i].x}%c, y: %c${box.touches[i].y}`, 'color: #ccc', 'color: #39f', 'color: #ccc', 'color: #39f');
    }
}
function handleBoxMove(evt) {
    evt.preventDefault();
    var touches = evt.changedTouches;
    for (var i = 0; i < touches.length; i++) {
        // console.log(`%cfor loop(i: %c${i}%c)`, 'color: #ccc', 'color: #39f', 'color: #ccc');
        var idx = ongoingTouchIndexById(touches[i].identifier);
        if (idx == 0) {
            // console.log(`%c â†’ idx: %c${idx}`, 'color: #ccc;', 'color: #39f;');
            // console.log("continuing touch "+idx);
            // console.log(`%cbox â†’ moveTo(%c${ongoingTouches[idx].pageX}%c, %c${ongoingTouches[idx].pageY}%c);`, 'color: #ccc', 'color: #39f', 'color: #ccc', 'color: #39f', 'color: #ccc');
            let nx = ongoingTouches[idx].pageX - box.touches[idx].x;
            let ny = ongoingTouches[idx].pageY - box.touches[idx].y;
            // console.log(`%c â†’ nx: %c${nx}%c, ny: %c${ny}`, 'color: #ccc;', 'color: #39f;', 'color: #ccc;', 'color: #39f;');
            if(s.log){
                let arrowTagX = 'â†â†’';
                let arrowTagY = 'â†‘â†“';
                if(nx < 0){arrowTagX = 'â†';} else if(nx > 0) {arrowTagX = 'â†’';}
                if(ny < 0){arrowTagY = 'â†‘';} else if(ny > 0) {arrowTagY = 'â†“';}
                console.log(`%c â†’ nx: %c${nx}%c, ny: %c${ny}`, 'color: #ccc;', 'color: #39f; background-color: #06c3; border-radius: 4px;', 'color: #ccc;', 'color: #39f; background-color: #06c3; border-radius: 4px;');
                console.log(`%cğŸŒ going: %c${arrowTagX}|${arrowTagY}`, 'color: #ccc;', 'color: #fff; background-color: #06c3; border-radius: 4px;');
            }
            box.x += nx;
            box.y += ny;
            let x = (box.x % 360).toFixed(2);
            let y = (box.y % 360).toFixed(2);
            box2.style = `--x-deg: ${x}deg; --y-deg: ${y}deg;`;

            box.touches[idx].x = ongoingTouches[idx].pageX;
            box.touches[idx].y = ongoingTouches[idx].pageY;

            /* 
            up goes left
            down goes right
            left goes down
            right goes up
                */

            ongoingTouches.splice(idx, 1, copyTouch(touches[i]));  // swap in the new touch record
            if(s.log){ console.log("."); }
        } else {
            console.log("can't figure out which touch to continue");
        }
    }
}
function handleBoxEnd(evt) {
    evt.preventDefault();
    var touches = evt.changedTouches;
    for (var i = 0; i < touches.length; i++) {
        var idx = ongoingTouchIndexById(touches[i].identifier);
        if (idx >= 0) {
            ongoingTouches.splice(idx, 1);  // remove it; we're done
            box.touches.splice(idx, 1);
        } else {
            console.log("can't figure out which touch to end");
        }
    }
    box.grabing = false;
    if(s.log){console.log(`%ctouchend%c â†’ handleBoxEnd()`, 'color: #f39; background-color: #f392; border-radius: 4px; padding: 2px;', 'color: #999;');}
}
function handleBoxCancel(evt) {
    evt.preventDefault();
    console.log("touchcancel.");
    var touches = evt.changedTouches;

    for (var i = 0; i < touches.length; i++) {
        var idx = ongoingTouchIndexById(touches[i].identifier);
        ongoingTouches.splice(idx, 1);  // remove it; we're done
        box.touches.splice(idx, 1);
    }
    box.grabing = false;
    if(s.log){console.log(`%ctouchcancel%c â†’ handleBoxCancel()`, 'color: #ff3; background-color: #ff32; border-radius: 4px; padding: 2px;', 'color: #999;');}
}

function copyTouch({ identifier, pageX, pageY }) {
    return { identifier, pageX, pageY };
}
function ongoingTouchIndexById(idToFind) {
    for (var i = 0; i < ongoingTouches.length; i++) {
        var id = ongoingTouches[i].identifier;

        if (id == idToFind) {
            return i;
        }
    }
    return -1;    // not found
}

window.addEventListener('load', (ev) => {
    console.log(`Welcome to my Lab!`);
    updateSettings();
    // start();
    // update();
    // cmap = Build3dMap(3,3,3);
    // cmap = BuildRand3dMap(3,3,3);
    // cmap = BuildRand3dMap(5,5,5);
    // cmap = Exp_BuildRand3dMap(5,5,5);
    // cmap = Exp_BuildRand3dMap(3,3,3);
    // cmap = Exp_BuildRand3dMap(5,5,5);
    // console.log(cmap);

    // level = new Maze3(3,3,3);
    // level.MakePath();
    // cmap = Build3dMapDisplay(level.maze,3,3,3);
    level = new Maze3(5,5,5);
    level.MakePath();
    // cmap = Build3dMapDisplay(level.maze,5,5,5);
    cmap = Build3dMapDisplaySteps(level.maze,level.stepMap,5,5,5);


    let clog = LogOut(cmap);
    DisplayCube(clog);

    startup();
});
/* Version Log:
[index-nds-00]: Default Template.
[index-nds-01]: 
[index-nds-02]: 
[index-nds-03]: 
[index-nds-04]: 
[index-nds-05]: 
[index-nds-06]: Makes a random new 3d Maze each time.
[index-nds-07]: 
[index-nds-08]: 
[index-nds-09]: 
[index-nds-10]: 
[index-nds-11]: 
[index-nds-12]: 

*/


/*
Notes:

x â†’
y â†“
z   â¥â†“ â¥‘â†’ â¥â† â¥â†‘ (bottom is forward, top is closer)

8	104	-x	rolls forward
2	98	 x	rolls back

6	102	-y	spins eastward counter-clockwise 
4	100	 y	spins westward clockwise

9	105	 z	rotates clockwise
7	103	-z	rotates counter-clockwise

+	109		more or less deg
-	107	


*/

/* Visualizing the cube and coordinates.

[14(20)x9]
..............[â€¢,â€¢,â€¢]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[â€¢,â€¢,â€¢]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[â€¢,â€¢,â€¢]
................/â”‚                   /â”‚                   /â”‚
.............../ â”‚                  / â”‚                  / â”‚
............../  â”‚                 /  â”‚                 /  â”‚
............./   â”‚                /   â”‚                /   â”‚
............/    â”‚               /    â”‚               /    â”‚
.........../     â”‚              /     â”‚              /     â”‚
.......[â€¢,â€¢,â€¢]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[â€¢,1,â€¢]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[â€¢,â€¢,â€¢]   â”‚
........./â”‚      â”‚            /â”‚      â”‚            /â”‚      â”‚
......../ â”‚      â”‚           / â”‚      â”‚           / â”‚      â”‚
......./  â”‚   [â€¢,â€¢,â€¢]â”€â”€â”€â”€â”€â”€â”€/â”€â”€â”‚â”€â”€â”€[â€¢,â€¢,-]â”€â”€â”€â”€â”€â”€â”€/â”€â”€â”‚â”€â”€â”€[â€¢,â€¢,â€¢]
....../   â”‚     /â”‚         /   â”‚     /â”‚         /   â”‚     /â”‚
...../    â”‚    / â”‚        /    â”‚    / â”‚        /    â”‚    / â”‚
..../     â”‚   /  â”‚       /     â”‚   /  â”‚       /     â”‚   /  â”‚
[â€¢,â€¢,â€¢]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[â€¢,â€¢,â€¢]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[â€¢,â€¢,â€¢]   â”‚  /   â”‚
...â”‚      â”‚ /    â”‚      â”‚      â”‚ /    â”‚      â”‚      â”‚ /    â”‚
...â”‚      â”‚/     â”‚      â”‚      â”‚/     â”‚      â”‚      â”‚/     â”‚
...â”‚   [-,â€¢,â€¢]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€[0,0,0]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€[1,â€¢,â€¢]   â”‚
...â”‚     /â”‚      â”‚      â”‚     /â”‚      â”‚      â”‚     /â”‚      â”‚ 
...â”‚    / â”‚      â”‚      â”‚    / â”‚      â”‚      â”‚    / â”‚      â”‚ 
...â”‚   /  â”‚   [â€¢,â€¢,â€¢]â”€â”€â”€â”‚â”€â”€â”€/â”€â”€â”‚â”€â”€â”€[â€¢,â€¢,â€¢]â”€â”€â”€â”‚â”€â”€â”€/â”€â”€â”‚â”€â”€â”€[â€¢,â€¢,â€¢]
...â”‚  /   â”‚     /       â”‚  /   â”‚     /       â”‚  /   â”‚     /
...â”‚ /    â”‚    /        â”‚ /    â”‚    /        â”‚ /    â”‚    /
...â”‚/     â”‚   /         â”‚/     â”‚   /         â”‚/     â”‚   /
[â€¢,â€¢,â€¢]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[â€¢,â€¢,1]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[â€¢,â€¢,â€¢]   â”‚  /
...â”‚      â”‚ /           â”‚      â”‚ /           â”‚      â”‚ /
...â”‚      â”‚/            â”‚      â”‚/            â”‚      â”‚/
...â”‚   [â€¢,â€¢,â€¢]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€[â€¢,-,â€¢]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€[â€¢,â€¢,â€¢]
...â”‚     /              â”‚     /              â”‚     /
...â”‚    /               â”‚    /               â”‚    /
...â”‚   /                â”‚   /                â”‚   /
...â”‚  /                 â”‚  /                 â”‚  /
...â”‚ /                  â”‚ /                  â”‚ /
...â”‚/                   â”‚/                   â”‚/
[â€¢,â€¢,â€¢]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[â€¢,â€¢,â€¢]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[â€¢,â€¢,â€¢]


there are 27 nodes, I want to give them a name, otherwise I will have to just try to remembe their location for names.

A way could be naming them in the same 1-9, but add decimals for the z layer.
z-: 1-9
z: 11-19
z+: 21-29


    const xyzSide = {
        0:{y:0,x:0},
        1:{y:1,x:-1},
        2:{y:1,x:0},
        3:{y:1,x:1},
        4:{y:0,x:-1},
        5:{y:0,x:0},
        6:{y:0,x:1},
        7:{y:-1,x:-1},
        8:{y:-1,x:0},
        9:{y:-1,x:1}
    };

    const xyzSide = {
        0:{z:-1,y:0,x:0},
        1:{z:-1,y:1,x:-1},
        2:{z:-1,y:1,x:0},
        3:{z:-1,y:1,x:1},
        4:{z:-1,y:0,x:-1},
        5:{z:-1,y:0,x:0},
        6:{z:-1,y:0,x:1},
        7:{z:-1,y:-1,x:-1},
        8:{z:-1,y:-1,x:0},
        9:{z:-1,y:-1,x:1}
        10:{z:0,y:0,x:0},
        11:{z:0,y:1,x:-1},
        12:{z:0,y:1,x:0},
        13:{z:0,y:1,x:1},
        14:{z:0,y:0,x:-1},
        15:{z:0,y:0,x:0},
        16:{z:0,y:0,x:1},
        17:{z:0,y:-1,x:-1},
        18:{z:0,y:-1,x:0},
        19:{z:0,y:-1,x:1}
        20:{z:1,y:0,x:0},
        21:{z:1,y:1,x:-1},
        22:{z:1,y:1,x:0},
        23:{z:1,y:1,x:1},
        24:{z:1,y:0,x:-1},
        25:{z:1,y:0,x:0},
        26:{z:1,y:0,x:1},
        27:{z:1,y:-1,x:-1},
        28:{z:1,y:-1,x:0},
        29:{z:1,y:-1,x:1}
    };

    we would still ignore [0,10,20], but all other variables fit with the needs we have.

    const sides = [2, 4, 6, 8];
    const sides_around = [1, 2, 3, 4, 6, 7, 8, 9];

    const sides = [5, 12, 14, 16, 18, 25];
    const sides_around = [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 16, 17, 18, 19, 21, 22, 23, 24, 25, 26, 27, 28, 29];


...............[021]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[022]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[023]
................/â”‚                   /â”‚                   /â”‚
.............../ â”‚                  / â”‚                  / â”‚
............../  â”‚                 /  â”‚                 /  â”‚
............./   â”‚                /   â”‚                /   â”‚
............/    â”‚               /    â”‚               /    â”‚
.........../     â”‚              /     â”‚              /     â”‚
........[011]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[+12]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[013]    â”‚
........./â”‚      â”‚            /â”‚      â”‚            /â”‚      â”‚
......../ â”‚      â”‚           / â”‚      â”‚           / â”‚      â”‚
......./  â”‚    [024]â”€â”€â”€â”€â”€â”€â”€â”€/â”€â”€â”‚â”€â”€â”€â”€[-25]â”€â”€â”€â”€â”€â”€â”€â”€/â”€â”€â”‚â”€â”€â”€â”€[026]
....../   â”‚     /â”‚         /   â”‚     /â”‚         /   â”‚     /â”‚
...../    â”‚    / â”‚        /    â”‚    / â”‚        /    â”‚    / â”‚
..../     â”‚   /  â”‚       /     â”‚   /  â”‚       /     â”‚   /  â”‚
.[001]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[002]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[003]    â”‚  /   â”‚
...â”‚      â”‚ /    â”‚      â”‚      â”‚ /    â”‚      â”‚      â”‚ /    â”‚
...â”‚      â”‚/     â”‚      â”‚      â”‚/     â”‚      â”‚      â”‚/     â”‚
...â”‚    [-14]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€[015]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€[+16]    â”‚
...â”‚     /â”‚      â”‚      â”‚     /â”‚      â”‚      â”‚     /â”‚      â”‚ 
...â”‚    / â”‚      â”‚      â”‚    / â”‚      â”‚      â”‚    / â”‚      â”‚ 
...â”‚   /  â”‚    [027]â”€â”€â”€â”€â”‚â”€â”€â”€/â”€â”€â”‚â”€â”€â”€â”€[028]â”€â”€â”€â”€â”‚â”€â”€â”€/â”€â”€â”‚â”€â”€â”€â”€[029]
...â”‚  /   â”‚     /       â”‚  /   â”‚     /       â”‚  /   â”‚     /
...â”‚ /    â”‚    /        â”‚ /    â”‚    /        â”‚ /    â”‚    /
...â”‚/     â”‚   /         â”‚/     â”‚   /         â”‚/     â”‚   /
.[004]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[+05]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[006]    â”‚  /
...â”‚      â”‚ /           â”‚      â”‚ /           â”‚      â”‚ /
...â”‚      â”‚/            â”‚      â”‚/            â”‚      â”‚/
...â”‚    [017]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€[-18]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€[019]
...â”‚     /              â”‚     /              â”‚     /
...â”‚    /               â”‚    /               â”‚    /
...â”‚   /                â”‚   /                â”‚   /
...â”‚  /                 â”‚  /                 â”‚  /
...â”‚ /                  â”‚ /                  â”‚ /
...â”‚/                   â”‚/                   â”‚/
.[007]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[008]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[009] 

[z,y,x]
..............[0,2,0]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[0,2,1]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[0,2,2]
................/â”‚                   /â”‚                   /â”‚
.............../ â”‚                  / â”‚                  / â”‚
............../  â”‚                 /  â”‚                 /  â”‚
............./   â”‚                /   â”‚                /   â”‚
............/    â”‚               /    â”‚               /    â”‚
.........../     â”‚              /     â”‚              /     â”‚
.......[1,2,0]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[1,2,1]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[1,2,2]   â”‚
........./â”‚      â”‚            /â”‚      â”‚            /â”‚      â”‚
......../ â”‚      â”‚           / â”‚      â”‚           / â”‚      â”‚
......./  â”‚   [0,1,0]â”€â”€â”€â”€â”€â”€â”€/â”€â”€â”‚â”€â”€â”€[0,1,1]â”€â”€â”€â”€â”€â”€â”€/â”€â”€â”‚â”€â”€â”€[0,1,2]
....../   â”‚     /â”‚         /   â”‚     /â”‚         /   â”‚     /â”‚
...../    â”‚    / â”‚        /    â”‚    / â”‚        /    â”‚    / â”‚
..../     â”‚   /  â”‚       /     â”‚   /  â”‚       /     â”‚   /  â”‚
[2,2,0]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[2,2,1]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[2,2,2]   â”‚  /   â”‚
...â”‚      â”‚ /    â”‚      â”‚      â”‚ /    â”‚      â”‚      â”‚ /    â”‚
...â”‚      â”‚/     â”‚      â”‚      â”‚/     â”‚      â”‚      â”‚/     â”‚
...â”‚   [1,1,0]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€[1,1,1]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€[1,1,2]   â”‚
...â”‚     /â”‚      â”‚      â”‚     /â”‚      â”‚      â”‚     /â”‚      â”‚ 
...â”‚    / â”‚      â”‚      â”‚    / â”‚      â”‚      â”‚    / â”‚      â”‚ 
...â”‚   /  â”‚   [0,0,0]â”€â”€â”€â”‚â”€â”€â”€/â”€â”€â”‚â”€â”€â”€[0,0,1]â”€â”€â”€â”‚â”€â”€â”€/â”€â”€â”‚â”€â”€â”€[0,0,2]
...â”‚  /   â”‚     /       â”‚  /   â”‚     /       â”‚  /   â”‚     /
...â”‚ /    â”‚    /        â”‚ /    â”‚    /        â”‚ /    â”‚    /
...â”‚/     â”‚   /         â”‚/     â”‚   /         â”‚/     â”‚   /
[2,1,0]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[2,1,1]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[2,1,0]   â”‚  /
...â”‚      â”‚ /           â”‚      â”‚ /           â”‚      â”‚ /
...â”‚      â”‚/            â”‚      â”‚/            â”‚      â”‚/
...â”‚   [1,0,0]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€[1,0,1]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€[1,0,2]
...â”‚     /              â”‚     /              â”‚     /
...â”‚    /               â”‚    /               â”‚    /
...â”‚   /                â”‚   /                â”‚   /
...â”‚  /                 â”‚  /                 â”‚  /
...â”‚ /                  â”‚ /                  â”‚ /
...â”‚/                   â”‚/                   â”‚/
[2,0,0]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[2,0,1]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[2,0,2]
*/

</script>
</body>
</html>